Как вы уже видели, объявление функции выглядит примерно так:

```js
function askQuestion() { // .. }
```

Как обсуждалось в главах 1 и 2, такое объявление функции создает во внешней области видимости (в данном случае это глобальная область видимости) идентификатор с именем `askQuestion`.

А как насчет следующей программы?
```js
var askQuestion = function ofTheTeacher(){ // .. }; М
```

То же самое можно сказать о создаваемой переменной `askQuestion`. Но поскольку она является функциональным выражением (определением функции, используемым как значение вместо автономного объявления), сама функция не «поднимается» (см. главу 5). У объявлений функций и функциональных выражений существует одно принципиальное отличие, связанное с идентификатором функции. Рассмотрим следующее функциональное выражение:

```js
var askQuestion = function ofTheTeacher(){ // .. };
```

Мы знаем, что `askQuestion` в итоге оказывается во внешней области видимости. Но как насчет идентификатора `ofTheTeacher`? Для формальных объявлений функции идентификатор оказывается во внешней/вмещающей области видимости, поэтому может быть разумно предположить, что и здесь происходит то же. Но `ofTheTeacher` объявляется как идентификатор внутри самой функции:

```js
var askQuestion = function ofTheTeacher() {
    console.log(ofTheTeacher);
};
askQuestion(); // function ofTheTeacher()...
console.log(ofTheTeacher); // ReferenceError: переменная ofTheTeacher не определена
```

На самом деле не совсем точно утверждать, что `ofTheTeacher` находится в области видимости функции. В приложении А, раздел «`Предполагаемые области видимости`», эта тема будет рассмотрена более подробно. 

Переменная `ofTheTeacher` не только объявляется внутри функции, а не снаружи, но и определяется как доступная только для чтения:

```js
var askQuestion = function ofTheTeacher() {
    "use strict";
    ofTheTeacher = 42;
    // TypeError //..
};
askQuestion(); // TypeError
```

Так как мы использовали `строгий режим`, о неудачной попытке присваивания сообщается как об ошибке TypeError; в нестрогом режиме при подобных присваиваниях просто происходит сбой без выдачи исключения.

А что, если функциональное выражение не имеет идентификатора?

```js
var askQuestion = function(){ // .. };
```

Функциональное выражение с идентификатором (именем) называется `именованным функциональным выражением`, а выражение без идентификатора называется `анонимным функциональным выражением`. Очевидно, у анонимных функциональных выражений нет идентификатора, влияющего на какую-либо из областей видимости.

Именованные и анонимные функциональные выражения рассматриваются намного подробнее (включая факторы, влияющие на решение об использовании одной или другой разновидности) в приложении А.

### Стрелочные функции

 ES6 в языке появилась дополнительная форма функциональных выражений — так называемые стрелочные функции: 

```js
var askQuestion = () => { // .. }; 
```

Для определения функций `=>` ключевое слово `function` не требуется. Кроме того, в некоторых простых случаях круглые скобки `(..)` вокруг списка параметров не обязательны. Также в некоторых случаях фигурные скобки `{..}`, в которые заключается тело функции, не обязательны. И если `{..}` опускаются, возвращаемое значение передается без использования ключевого слова `return`

К достоинствам стрелочных функций часто относится компактность синтаксиса; утверждается, что она равносильна созданию объективно более удобочитаемого кода. Это утверждение в лучшем случае сомнительно, а я считаю, что оно откровенно ошибочно. Удобочитаемость различных форм функций рассматривается в приложении А.

Стрелочные функции являются лексически анонимными; это означает, что в программе не существует напрямую связанного с ними идентификатора, который ссылается на функцию. Присваивание `askQuestion` создает автоматически определяемое имя `askQuestion`, но это не означает, что функция становится не анонимной:

```js
var askQuestion = () => { // .. 
};
 askQuestion.name; // askQuestion
```

Стрелочные функции достигают своей синтаксической краткости за счет того, что вам приходится в уме жонглировать несколькими разновидностями разных форм/условий. Примеры:

```js
() => 42;
id => id.toUpperCase();
(id,name) => ({ id, name }); 
(...args) => { return args[args.length 1]; };
```

Настоящая причина, по которой я поднял тему `стрелочных функций`, — частые, но ошибочные утверждения о том, что стрелочные функции иначе ведут себя в отношении `лексической области видимости` по сравнению со стандартными функциями `function`. Это не так. Помимо анонимности (и отсутствия декларативной формы), стрелочные функции `=>` подчиняются тем же правилам `лексической области видимости`, что и функции `function`. Стрелочная функция (с фигурными скобками {..} вокруг ее тела или без них) все равно создает отдельную, внутреннюю вложенную область видимости. Объявления переменной в этой вложенной области видимости подчиняются тем же правилам, что и в функциональной области видимости

### Итоги

При определении функции (объявления или выражения) создается новая область видимости. Расположение областей видимости, вложенных друг в друга, создает в программе естественную иерархию областей видимости, которая называется *цепочкой областей видимости*. *Цепочка областей видимости* управляет доступом к переменным.

Каждая новая область видимости предоставляет пространство для хранения ее собственного набора переменных. Если имя переменной повторяется на разных уровнях цепочки, происходит затенение, которое блокирует доступ к внешней переменной с этой точки по направлению к *внутренним областям*. 

Впрочем, довольно технических подробностей. В следующей главе мы перейдем к главной области видимости, которая присутствует во всех программах JS, а именно к *глобальной области видимости.* 
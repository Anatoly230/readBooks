### intro
В главах 1 и 2 приведено конкретное определение лексической области видимости (и ее частей), а также представлены полезные метафоры, которые помогают понять ее концептуальную основу. Прежде чем продолжать чтение этой главы, найдите кого-нибудь, кому можно объяснить (письменно или на словах), что такое лексическая область видимости и почему полезно понимать эту концепцию. Может показаться, что этот шаг можно пропустить, но мой опыт показывает, что объяснять эти идеи другим очень полезно. Это помогает нашему мозгу лучше усвоить изучаемый материал!
А теперь пришло время углубиться в технические подробности, так что должен предупредить: с этого момента описание становится намного более подробным. Но не пропускайте его, потому что оно по-настоящему дает понять, сколько вы еще не знаете об областях видимости (пока). Не торопитесь.
Чтобы напомнить контекст нашего постоянного примера, вспомним иллюстрацию вложенных областей видимости с цветными рамками из главы 2 (рис. 2).
Связи между областями видимости, вложенными между другими областями видимости, образуют цепочку областей видимости. Эта цепочка определяет путь, по которому можно обращаться к переменным. Она является однонаправленной, т. е. поиск движется только снизу вверх/наружу.

![350]( https://storage.piter.com/upload/new_folder/978544611876/fig2.png)

### «Поиск» (большей частью) концептуален
На рис. 2 обратите внимание на ссылку на переменную `students` из цикла `for`. Каким образом было определено, что она относится к области видимости `КРАСНЫЙ (1)`?
В главе 2 процедура обращения к переменной во время выполнения была описана термином «поиск». Поиск запускался `Движком`, для чего он спрашивал у `Менеджера области видимости текущей области видимости`, известен ли ему данный `идентификатор`/`переменная`, и продвигалось вверх/наружу по `цепочке вложенных областей видимости` (по направлению к `глобальной области видимости`), пока `идентификатор`/`переменная` не будет найден (если будет). Поиск останавливается при обнаружении первого объявления с подходящим именем в очередной области видимости. 
Процесс поиска определил, что `students` принадлежит `области видимости КРАСНЫЙ (1)`, потому что мы еще не нашли подходящее имя переменной при перемещении по `цепочке областей видимости`, пока не прибыли к последней `глобальной области видимости КРАСНЫЙ (1)`.
Аналогичным образом `идентификатор`/`переменная` `studentID` в команде `if` определяется как принадлежащий `области видимости СИНИЙ (2)`. 
Такое описание процесса поиска во время выполнения хорошо работает для концептуального понимания, но на практике все обычно происходит не так.
Цвет банки, в которой лежит камешек (т. е. метаинформация о том, из какой `области видимости происходит` переменная), обычно определяется во время исходного процесса компиляции. Так как `лексическая область видимости` на этот момент более или менее фиксирована, цвет камешка не изменится под воздействием каких-либо факторов, возникших позднее на стадии выполнения. 
Так как цвет камешка известен с момента компиляции и остается неизменным, эта информация с большой вероятностью будет храниться в узле каждой переменной в `AST` (или, по крайней мере, будет доступна из него); эта информация затем явно используется исполняемыми командами программы. 
Иначе говоря, `Движку` (из главы 2) не нужно просматривать набор областей видимости, чтобы понять, из какой `области видимости` происходит переменная. Эта информация уже известна! Предотвращение поиска на стадии выполнения — ключевое преимущество `лексических областей видимости` для оптимизации быстродействия. Исполнительная система действует более эффективно, когда ей не приходится тратить время на эти поиски. 
Но я совсем недавно сказал «…обычно определяется…», когда речь зашла об определении цвета камешка во время компиляции. В каком же случае эта информация не будет известна во время компиляции? 
Возьмем ссылку на переменную, которая не объявляется ни в одной лексически доступной `области видимости` в текущем файле — см. книгу 1 «Познакомьтесь, JavaScript», где сказано, что каждый файл является самостоятельной программой с точки зрения компиляции `JS`. Если объявление не найдено, это не обязательно является ошибкой. Другой файл (программа) на стадии выполнения может объявить эту переменную в общей области видимости.
Итак, окончательное определение того, была ли переменная правильно объявлена в некоторой доступной `области видимости`, иногда приходится откладывать до стадии выполнения.
Любая ссылка на изначально необъявленную переменную остается в виде «неокрашенного камешка» во время компиляции файла; ее цвет невозможно определить до того, как будут откомпилированы другие файлы и не активизируется исполнительная среда приложения. Отложенный поиск в конечном итоге определит, в какой области видимости была обнаружена переменная (скорее всего, в глобальной). 
Однако этот поиск потребуется выполнить не более одного раза на каждую переменную, так как никакие факторы во время выполнения не смогут изменить «цвет камешка». В разделе «Неудача при поиске» главы 2 рассказано, что происходит, если камешек остается неокрашенным в момент выполнения ссылки на него на стадии выполнения программы. 

### Затенение

В нашем постоянном примере для этих глав используются разные имена переменных для разных областей видимости. Так как имена уникальны, в каком-то смысле можно было бы с таким же успехом хранить их все в одной области видимости (например, КРАСНЫЙ (1)).

Различия между `лексическими областями видимости` начинают играть более важную роль, когда в программе встречаются две и более переменные с одинаковыми именами, определенные в разных областях видимости. В одной области видимости не может быть двух и более переменных с совпадающими именами; такие множественные ссылки будут интерпретироваться как одна переменная. 

Таким образом, если вам потребуется создать две и более переменные с одинаковыми именами, необходимо использовать разные (часто вложенные) области видимости. И в этом случае очень важно, как эти области видимости расположены относительно друг друга.

Пример: 

```js
var studentName = "Suzy";
 function printStudent(studentName) {
  studentName = studentName.toUpperCase();
   console.log(studentName);
    } 
    printStudent("Frank"); // FRANK 
    printStudent(studentName); // SUZY
     console.log(studentName); // Suzy
```

Переменная `studentName` в строке 1 (команда `var studentName = ..`) создает переменную в `области видимости КРАСНЫЙ (1)`. Одноименная переменная объявляется как принадлежащая `области видимости СИНИЙ (2)` в строке 3 (параметр в определении функции `printStudent(..)`).

>[!info] Примечание
>Прежде чем читать дальше, попробуйте проанализировать этот код с применением различных приемов/метафор, представленных в книге. В частности, постарайтесь определить «цвета» (т. е. области видимости) переменных в этом фрагменте. Это полезная тренировка!

К какому цвету будет относиться `studentName` в команде присваивания `studentName = studentName.toUpperCase()` и в команде `console.log(studentName)`? Все три ссылки на` studentName` будут принадлежать СИНИЙ (2).

В концептуальном описании поиска было сказано, что он начинается с текущей области видимости, распространяется наружу/ наверх и останавливается только при обнаружении подходящей переменной.

Переменная `studentName` из СИНИЙ (2) обнаруживается немедленно. Переменная `studentName` из КРАСНЫЙ (1) даже не рассматривается.

В этом проявляется ключевой аспект поведения `лексических областей видимости`, называемый `затенением`. Переменная (параметр) `studentName` из СИНИЙ (2) замещает переменную `studentName` из КРАСНЫЙ (1). Таким образом, параметр затеняет (затеняемую) глобальную переменную. Несколько раз повторите это предложение про себя и убедитесь в том, что вы правильно понимаете терминологию! 

Вот почему повторное присваивание `studentName` влияет только на внутреннюю переменную (параметр): из области видимости СИНИЙ (2), а не `studentName` из глобальной области видимости КРАСНЫЙ (1). 

Когда вы решаете заместить переменную из внешней области видимости, одно из прямых следствий заключается в том, что из этой области видимости вниз/вовнутрь (через все вложенные области видимости) переменная с этим именем уже не может быть отнесена к области видимости затененной переменной (КРАСНЫЙ (1) в данном случае). Иначе говоря, любая ссылка на идентификатор `studentName` будет соответствовать переменной параметру и никогда — глобальной переменной `studentName`. Лексически невозможно сослаться на глобальную переменную `studentName` в какой-либо точке внутри функции `printStudent(..)` (или любой из вложенных областей видимости).

##### Трюк с обратным затенением

Пожалуйста, учтите: пользоваться приемом, который я здесь опишу, не рекомендуется. Его полезность ограниченна, он запутывает читателей вашего кода и, скорее всего, приведет к появлению ошибок в программе. Я рассматриваю его только потому, что вы можете столкнуться с этим поведением в существующих приложениях, и лучший способ избежать путаницы — понять, что же происходит в программе. 

К глобальной переменной можно обратиться из области видимости, в которой эта переменная была затенена, но обычно ссылки на лексический идентификатор будет недостаточно.

В глобальной области видимости (КРАСНЫЙ (1)) объявления `var` и объявления функций также предоставляются как свойства (с таким же именем, как у идентификатора) глобального объекта — по сути, объектного представления глобальной области видимости. Если вы писали код `JS` для браузера, вероятно, вы узнаете `глобальный объект` с именем `window`. Это не совсем точно, но достаточно для нашего обсуждения. В следующей главе тема глобальной области видимости/объекта будет рассмотрена более подробно. 

Рассмотрим следующую программу, которая специально выполняется как автономный файл .js в среде браузера: 

```js
var studentName = "Suzy";
function printStudent(studentName) { 
	console.log(studentName);
	console.log(window.studentName);
  }
   printStudent("Frank"); // "Frank" // "Suzy"
```

Заметили ссылку `window.studentName`? Это выражение обращается к глобальной переменной studentName как свойству `window` (объект, который мы пока считаем синонимом глобального объекта). Это единственный способ обратиться к замещенной переменной из области видимости, в которой находится замещающая переменная. 

Выражение `window.studentName` является синонимом глобальной переменной `studentName`, а не отдельной копией. Изменения в одной переменной будут отражаться в другой (в обоих направлениях). Выражение `window.studentName` можно рассматривать как альтернативный `get`/`set` синтаксис для обращения к реальной переменной `studentName`. Собственно, вы даже можете добавить переменную в глобальную область видимости, создавая/задавая свойство глобального объекта.

>[!info] Примечание
>Помните: то, что вы можете что-то сделать, вовсе не означает, что это стоит делать. Не затеняйте глобальную переменную, к которой нужно обращаться, и наоборот — по возможности не используйте этот прием для обращения к затененной глобальной переменной. И ни в коем случае не путайте читателей своего кода, создавая глобальные переменные как свойства `window` вместо формальных объявлений!

Этот маленький трюк подходит только для обращения к переменной из глобальной области видимости (не замещенной переменной из вложенной области видимости), и даже в этом случае только переменной, объявленной с ключевым словом `var` или `function`. 

Другие формы объявлений в глобальной области видимости не создают зеркальных свойств глобального объекта:

```js
var one = 1;
let notOne = 2;
const notTwo = 3;
class notThree {}
 console.log(window.one); // 1
 console.log(window.notOne); // undefined 
 console.log(window.notTwo); // undefined
 console.log(window.notThree); // undefined
```

Переменные (как бы они ни были объявлены), существующие в любой другой области видимости, кроме глобальной, полностью недоступны в той области видимости, в которой они были замещены:

```js
var special = 42;
function lookingFor(special) {
    // Идентификатор `special` (параметр) в этой
    //области видимости замещается внутри keepLooking()
    // и поэтому недоступен из этой области видимости.
    function keepLooking() {
        var special = 3.141592;
        console.log(special);
        console.log(window.special);
    }
    keepLooking();
}
lookingFor(112358132134); // 3.141592 // 42
```

Глобальная переменная `special` (КРАСНЫЙ (1)) замещается переменной из СИНИЙ (2) (параметр), а переменная `special` из СИНИЙ (2) сама замещается переменной special из ЗЕЛЕНЫЙ (3) внутри `keepLooking()`. К переменной `special` из КРАСНЫЙ (1) все еще можно обратиться по косвенной ссылке `window.special`. Однако `keepLooking()` никак не сможет обратиться к переменной special из области видимости СИНИЙ (2), содержащей `число 112358132134`. 

##### Копирование — не обращение

Следующий вопрос «но как насчет…?» мне задавали десятки раз. Пример:

```js
var special = 42;
function lookingFor(special) {
    var another = { special: special };
    function keepLooking() {
        var special = 3.141592;
        console.log(special);
        console.log(another.special);
        // Все сложно!
        console.log(window.special);
    } keepLooking();
}
lookingFor(112358132134); // 3.141592 // 112358132134 // 42
```

Выходит, другой объектный прием опровергает мое утверждение о том, что специальный параметр «полностью недоступен» из `keepLooking()`? Нет, утверждение остается истинным. 

`special: special` копирует значение переменной-параметра `special` в другой контейнер (одноименное свойство). Конечно, если вы помещаете значение в другой контейнер, затенение уже не действует (если только оно тоже не было затенено). Но это не означает, что мы обращаемся к параметру `special`; это означает, что мы обращаемся к копии его значения на тот момент через другой контейнер (свойство объекта). Параметру `special` из СИНИЙ (2) не удастся присвоить другое значение из keepLooking().

Другой вопрос из серии «но…?!», который у вас может возникнуть: а что, если использовать в качестве значений объекты или массивы вместо чисел (`112358132134 `и т. д.)? Не решат ли ссылки на объекты вместо копий примитивных значений проблему недоступности? 

Нет. Изменение содержимого объектного значения через копию ссылки — не то же самое, что лексическое обращение к самой переменной. Мы все равно не сможем присвоить другое значение параметру special из СИНИЙ (2).
##### Недопустимое затенение

Не все комбинации замещения объявлений допустимы. `let` может замещать `var`, но `var` не может замещать `let`:

```js
function something() {
    var special = "JavaScript";
    {
        let special = 42;
        // допустимое Затенение // ..
    }
}
function another() {
    // ..
    {
        let special = "JavaScript";
        {
            var special = "JavaScript";
            // ^^^ Синтаксическая ошибка // ..
        }
    }
}
```

Обратите внимание: в функции `another()` внутреннее объявление `var special` пытается объявить `special`, что само по себе нормально (как показывает функция `something())`. 

Описание синтаксической ошибки в данном случае сообщает, что переменная `special` уже была определена, но это сообщение содержит дезинформацию. Еще раз: в `something()` такой ошибки нет, так как в замещении обычно ничего плохого нет. 

Настоящая причина, по которой выдается ошибка `SyntaxError`, заключается в том, что `var` фактически пытается пересечь границу («перепрыгнуть») одноименного объявления `let`, что недопустимо. Запрет на пересечение границы фактически останавливается на каждой границе функции, так что в этом варианте исключение не возникает:

```js
function another() {
    // ..
    {
        let special = "JavaScript";
        ajax("https://some.url", function callback() {
            // абсолютно нормальное Затенение
            var special = "JavaScript";
            // ..
        });
    }
}
```

Подведем итог: объявление `let` (во внутренней области видимости) всегда может затенить объявление `var` во внешней области видимости. Объявление `var` (во внутренней области видимости) может затенить объявление `let` во внешней области видимости только в том случае, если между ними есть граница функции.

### Область видимости имени функции

Как вы уже видели, объявление функции выглядит примерно так:

```js
function askQuestion() { // .. }
```

Как обсуждалось в главах 1 и 2, такое объявление функции создает во внешней области видимости (в данном случае это глобальная область видимости) идентификатор с именем `askQuestion`.

А как насчет следующей программы?
```js
var askQuestion = function ofTheTeacher(){ // .. }; М
```

То же самое можно сказать о создаваемой переменной `askQuestion`. Но поскольку она является функциональным выражением (определением функции, используемым как значение вместо автономного объявления), сама функция не «поднимается» (см. главу 5). У объявлений функций и функциональных выражений существует одно принципиальное отличие, связанное с идентификатором функции. Рассмотрим следующее функциональное выражение:

```js
var askQuestion = function ofTheTeacher(){ // .. };
```

Мы знаем, что `askQuestion` в итоге оказывается во внешней области видимости. Но как насчет идентификатора `ofTheTeacher`? Для формальных объявлений функции идентификатор оказывается во внешней/вмещающей области видимости, поэтому может быть разумно предположить, что и здесь происходит то же. Но `ofTheTeacher` объявляется как идентификатор внутри самой функции:

```js
var askQuestion = function ofTheTeacher() {
    console.log(ofTheTeacher);
};
askQuestion(); // function ofTheTeacher()...
console.log(ofTheTeacher); // ReferenceError: переменная ofTheTeacher не определена
```

На самом деле не совсем точно утверждать, что `ofTheTeacher` находится в области видимости функции. В приложении А, раздел «`Предполагаемые области видимости`», эта тема будет рассмотрена более подробно. 

Переменная `ofTheTeacher` не только объявляется внутри функции, а не снаружи, но и определяется как доступная только для чтения:

```js
var askQuestion = function ofTheTeacher() {
    "use strict";
    ofTheTeacher = 42;
    // TypeError //..
};
askQuestion(); // TypeError
```

Так как мы использовали `строгий режим`, о неудачной попытке присваивания сообщается как об ошибке TypeError; в нестрогом режиме при подобных присваиваниях просто происходит сбой без выдачи исключения.

А что, если функциональное выражение не имеет идентификатора?

```js
var askQuestion = function(){ // .. };
```

Функциональное выражение с идентификатором (именем) называется `именованным функциональным выражением`, а выражение без идентификатора называется `анонимным функциональным выражением`. Очевидно, у анонимных функциональных выражений нет идентификатора, влияющего на какую-либо из областей видимости.

Именованные и анонимные функциональные выражения рассматриваются намного подробнее (включая факторы, влияющие на решение об использовании одной или другой разновидности) в приложении А.

### Стрелочные функции

 ES6 в языке появилась дополнительная форма функциональных выражений — так называемые стрелочные функции: 

```js
var askQuestion = () => { // .. }; 
```

Для определения функций `=>` ключевое слово `function` не требуется. Кроме того, в некоторых простых случаях круглые скобки `(..)` вокруг списка параметров не обязательны. Также в некоторых случаях фигурные скобки `{..}`, в которые заключается тело функции, не обязательны. И если `{..}` опускаются, возвращаемое значение передается без использования ключевого слова `return`

К достоинствам стрелочных функций часто относится компактность синтаксиса; утверждается, что она равносильна созданию объективно более удобочитаемого кода. Это утверждение в лучшем случае сомнительно, а я считаю, что оно откровенно ошибочно. Удобочитаемость различных форм функций рассматривается в приложении А.

Стрелочные функции являются лексически анонимными; это означает, что в программе не существует напрямую связанного с ними идентификатора, который ссылается на функцию. Присваивание `askQuestion` создает автоматически определяемое имя `askQuestion`, но это не означает, что функция становится не анонимной:

```js
var askQuestion = () => { // .. 
};
 askQuestion.name; // askQuestion
```

Стрелочные функции достигают своей синтаксической краткости за счет того, что вам приходится в уме жонглировать несколькими разновидностями разных форм/условий. Примеры:

```js
() => 42;
id => id.toUpperCase();
(id,name) => ({ id, name }); 
(...args) => { return args[args.length 1]; };
```

Настоящая причина, по которой я поднял тему `стрелочных функций`, — частые, но ошибочные утверждения о том, что стрелочные функции иначе ведут себя в отношении `лексической области видимости` по сравнению со стандартными функциями `function`. Это не так. Помимо анонимности (и отсутствия декларативной формы), стрелочные функции `=>` подчиняются тем же правилам `лексической области видимости`, что и функции `function`. Стрелочная функция (с фигурными скобками {..} вокруг ее тела или без них) все равно создает отдельную, внутреннюю вложенную область видимости. Объявления переменной в этой вложенной области видимости подчиняются тем же правилам, что и в функциональной области видимости

### Итоги

При определении функции (объявления или выражения) создается новая область видимости. Расположение областей видимости, вложенных друг в друга, создает в программе естественную иерархию областей видимости, которая называется *цепочкой областей видимости*. *Цепочка областей видимости* управляет доступом к переменным.

Каждая новая область видимости предоставляет пространство для хранения ее собственного набора переменных. Если имя переменной повторяется на разных уровнях цепочки, происходит затенение, которое блокирует доступ к внешней переменной с этой точки по направлению к *внутренним областям*. 

Впрочем, довольно технических подробностей. В следующей главе мы перейдем к главной области видимости, которая присутствует во всех программах JS, а именно к *глобальной области видимости.* 
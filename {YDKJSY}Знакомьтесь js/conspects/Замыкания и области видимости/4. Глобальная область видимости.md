### intro

В [[3. Цепочка областей видимости|главе 3]] *глобальная область видимости* упоминалась несколько раз, но, возможно, вы все еще задаетесь вопросом, почему *наружная область видимости* программы играет такую важную роль в современном `JS`. Подавляющее большинство работы сейчас выполняется внутри *функций* и *модулей*, а не глобально. 

Можно ли просто заявить: «Избегайте *глобальной области видимости*» — и считать, что этого достаточно? 

*Глобальная область видимости программы* `JS` — богатая тема, которая содержит гораздо больше практической ценности и всевозможных нюансов, чем можно было бы ожидать. В этой главе мы сначала выясним, почему *глобальная область видимости* (все еще) полезна и актуальна для написания современных программ `JS`, а затем рассмотрим различия в том, где и как обращаться к *глобальной области видимости* в разных средах `JS`.

Полное понимание *глобальной области видимости* критично для вашего умения использовать *лексические области видимости* для формирования структуры ваших программ.

### Для чего нужна глобальная область видимости?

Вряд ли кого-нибудь из читателей удивит, что большинство приложений строится из нескольких (иногда многих) отдельных файлов `JS`. Как же все эти раздельные файлы собираются воедино движком `JS` в одном контексте исполнения?

Относительно приложений, выполняемых в браузере, есть три основных способа.

1. Если вы напрямую используете модули *ES* (без их транспиляции в другой формат упаковки модулей), эти файлы загружаются по отдельности средой `JS`. Затем каждый модуль импортирует ссылки на любые другие модули, к которым он должен обращаться. Файлы модулей взаимодействуют друг с другом исключительно через эти директивы импортирования, никакая общая внешняя область видимости им для этого не нужна.

2. если вы используете упаковщик в своем процессе сборки приложения, все файлы обычно объединяются посредством конкатенации перед их передачей браузеру и движку `JS`, после чего обрабатывается только один большой файл. Даже когда все фрагменты приложения хранятся в одном файле, потребуется некий механизм, при помощи которого каждый фрагмент может зарегистрировать имя, к которому будут обращаться другие фрагменты, а также некоторые средства для реализации таких обращений.

В некоторых конфигурациях сборки приложений все содержимое файла упаковывается в одну `внешнюю область видимости` — например, *функцию-обертку*, *универсальный модуль* (UMD — см. приложение А) и т. д. Каждый фрагмент может зарегистрироваться для обращений со стороны других фрагментов, для чего используются локальные переменные этой общей области видимости. 
Пример:

```js
(function wrappingOuterScope() {
    var moduleOne = (function one() {
        // .. })();
        var moduleTwo = (function two() {
            // .. function callModuleOne()
            {
                moduleOne.someMethod();
            }
            // ..
        })();
    })();
```

Как видно из этого фрагмента, внутри области видимости функции `wrappingOuterScope()` объявляются локальные переменные `moduleOne` и `moduleTwo`, чтобы эти модули могли обращаться друг к другу для взаимодействия.

Хотя *область видимости* `wrappingOuterScope()` является функцией, а не полноценной средой *глобальной области видимости*, она работает как своего рода область видимости уровня приложения — область, в которой могут храниться все идентификаторы верхнего уровня (хотя и не является настоящей глобальной областью видимости.) В этом отношении она является своего рода заменителем глобальной области видимости.

И наконец:
3. -й  способ независимо от того, используется ли для приложения программа-упаковщик или же файлы (кроме модулей `ES`) просто загружаются в браузере по отдельности (при помощи тегов `<script>` или других средств динамической загрузки ресурсов `JS`), если не существует одной охватывающей *области видимости* для всех этих фрагментов, *глобальная область видимости* становится единственным способом организации взаимодействия между ними.

Упакованный файл такого рода часто выглядит примерно так:

```js
var moduleOne = (function one() {
    // ..
})();
var moduleTwo = (function two() {
    // .. function callModuleOne()
    {
        moduleOne.someMethod();
    } // ..
})();
```

В данном случае окружающая область видимости функции отсутствует, поэтому объявления `moduleOne` и `moduleTwo` просто размещаются в `глобальной области видимости`. По сути это то же самое, как если бы файлы не объединялись конкатенацией, но загружались по отдельности:

```js
// module1.`JS`:
var moduleOne = (function one() {
    // ..
})();
//  module2.`JS`:
var moduleTwo = (function two() {
    // .. function callModuleOne()
    {
        moduleOne.someMethod();
    }
    // ..
})();
```

Если эти файлы загружаются по отдельности как обычные автономные файлы `.js` в среде браузера, каждое объявление переменной верхнего уровня оказывается глобальной переменной, так как *глобальная область видимости* оказывается единственным общим ресурсом для этих двух разных файлов — с точки зрения движка `JS`, они являются независимыми программами.

Кроме (потенциального) ведения учета того, где код приложения размещается во время выполнения, и возможностей каждого фрагмента по обращению к другим фрагментам для взаимодействия с ними в глобальной области видимости также:

 `JS` предоставляет доступ к своим встроенным 
 - примитивам: `undefined`, `null`, `Infinity`,` NaN`;
 - платформенным средствам: `Date()`, `Object()`, `String()` и т. д.; 
 - глобальным функциям: `eval()`, `parseInt()` и т. д.; 
 - пространствам имен: `Math`, `Atomics`, `JSON`; 
-  сопутствующим средствам: `Intl`, `WebAssembly`;
 
 среда, под управлением которой работает движок `JS`, предоставляет доступ к своим встроенным
 - консоли (и ее методам);
 - средствам `DOM` (`window`,` document` и т. д.);
 - таймерам (`setTimeout(..)` и т. д.);
 - `API` веб-платформы: `navigator`, `history`, `location`, `WebRTC` и т. д.

И это далеко не все глобальные средства, с которыми может взаимодействовать ваша программа.

>[!info] Примечание 
>`Node` также предоставляет несколько элементов «глобально», но с технической точки зрения они не находятся в `глобальной области видимости`: `require()`, `dirname`, `module`, `URL` и т. д.

Разработчики обычно согласны с тем, что *глобальная область видимости* не должна становиться свалкой для всех переменных вашего приложения. Свалка только создает хаос для многочисленных ошибок. Тем не менее нельзя отрицать, что *глобальная область видимости* становится важной связующей средой практически для любых приложений `JS`.
### Где именно находится глобальная область видимости?

Казалось бы, *глобальная область видимости* должна находиться во внешней части файла (т. е. не внутри какой-либо функции или другого блока). Но на самом деле все не так просто.

Разные среды `JS` по-разному обрабатывают *области видимости* вашей программы, особенно глобальную. У разработчиков `JS` часто встречаются заблуждения по этому поводу, даже если они не до конца понимают это. 

#### Объект `window` в браузере

В отношении *глобальной области видимости* самая чистая среда, в которой может работать `JS`, — это автономный файл `.js`, загружаемый в окружение веб-страницы в браузере. Под чистотой я имею в виду не то, что к ней ничего не добавляется (добавляться может очень многое), а скорее минимальное вмешательство в работу кода или ожидаемое поведение *глобальной области видимости*.

Рассмотрим следующий файл .js:

```js
var studentName = "Kyle";
function hello() {
    console.log(`Hello, ${studentName}!`);
}

hello(); // Hello, Kyle!
```

Этот код может быть загружен на веб-страницу при помощи встроенного тега 
- `<script>,`
- тега `<script src=..>` в разметке или даже динамически созданного элемента
- `DOM` `<script>`.
Во всех трех случаях идентификаторы `studentName` и `hello` объявляются в `глобальной области видимости`.

Это означает, что при обращении к `глобальному объекту` (обычно это объект `window` в браузере) вы найдете в нем одноименные свойства:

```js
var studentName = "Kyle";
function hello() {
    console.log(`Hello, ${window.studentName}!`);
}
window.hello(); // Hello, Kyle!
```

Это поведение по умолчанию, которое следует ожидать после чтения спецификации `JS`: ***внешняя область видимости является глобальной, а `studentName` законно создается как глобальная переменная***.

Вот что я имею в виду под чистотой. Но, к сожалению, это относится не ко всем средам `JS`, с которыми вы столкнетесь, и часто это оказывается неожиданным для разработчиков `JS`.
#### Затенение глобальных имен глобальными именами

Вспомните описание затенения (и глобального обратного затенения) из главы 3: одно объявление переменной может переопределить объявление одноименной переменной из *внешней области видимости* и заблокировать доступ к ней.

Неожиданное последствие различий между *глобальной переменной* и *одноименным глобальным свойством* заключается в том, что внутри самой *глобальной области видимости* свойство глобального объекта может быть затенено глобальной переменной:

```js
window.something = 42;
let something = "Kyle";
console.log(something); // Kyle
console.log(window.something); // 42
```

Объявление `let` добавляет *глобальную переменную* `something`, но не свойство *глобального объекта* (см. главу 3). В результате лексический идентификатор `something` затеняет свойство глобального объекта `something`

Создавать расхождения между *глобальным объектом* и *глобальной областью видимости* почти всегда нежелательно. Они почти наверняка собьют с толку читателей вашего кода. 

Все эти ловушки с *глобальными объявлениями* можно просто обойти: всегда используйте `var` для *глобальных имен*. `let` и `const` следует зарезервировать для *блоковых областей видимости* (см. раздел «Области видимости с блоками» главы 6).
#### Глобальные средства DOM

Я утверждал, что среда `JS` под управлением браузера обладает самым чистым поведением *глобальной области видимости*, которая вам встретится. При этом она не является абсолютно чистой.

В приложениях `JS` на базе браузеров встречается один удивительный аспект поведения: элемент `DOM` с идентификатором `id` автоматически создает *глобальную переменную*, которая ссылается на него. 

Возьмем следующую разметку:

```html
<ul id="my-todo-list"> 
	<li id="first">Write a book</li> 
	..
 </ul>
```

А код `JS` этой страницы может включать следующий фрагмент:

```js 
first; // <li id="first">..</li>
window["my-todo-list"]; // <ul id="my-todo-list">..</ul>
```

Если значение `id` является допустимым *лексическим именем* (таким как `first`), то будет создана лексическая переменная. Если нет, то обращение к этому глобальному элементу возможно только через *глобальный объект* (`window[..]`).

Автоматическая регистрация всех элементов `DOM` с идентификатором `id` — поведение, унаследованное от старых браузеров, которое должно оставаться, потому что многие старые сайты зависят от него. Мой совет: никогда не используйте эти глобальные переменные, хотя они всегда будут незаметно создаваться. 
#### Что в имени тебе моем?

Другая странность глобальной области видимости, встречающаяся в коде `JS` для браузеров:

```js
var name = 42;
console.log(name, typeof name); // "42" string
```

`window.name` — заранее определенный глобальный элемент в контексте браузера; это свойство *глобального объекта*, поэтому оно выглядит как нормальная *глобальная переменная* (однако ничего общего с «нормальностью» у него нет).

Мы использовали для объявления `var`, чтобы избежать затенения заранее определенного *глобального свойства* `name`. Фактически это означает, что объявление `var` игнорируется, так как у объекта глобальной области видимости уже есть свойство с таким именем. Как упоминалось ранее, если бы мы использовали `let name`, это привело бы к затенению `window.name` отдельной глобальной переменной `name`

Но по-настоящему удивительно то, что, хотя мы присвоили `name` (а следовательно, и `window.name`) значение `42`, при получении значения вы получите строку `"42"`. В данном случае странность возникает из-за того, что `name` в действительности является заранее определенным `get`/`set`-свойством объекта, которое настаивает на том, что его значение является строкой. ***С ума сойти!***

За исключением редких граничных случаев (таких как идентификатор элемента `DOM` и `window.name`), при выполнении `JS` из автономного файла в странице браузера наблюдается наиболее чистое поведение *глобальной области видимости* из тех, которые можно встретить.

#### Веб-работники

Веб-работники (*Web Workers*) — расширение веб-платформы, работающее на базе поведения `JS` в браузере, что позволяет файлу `JS` выполняться в потоке (уровня операционной системы), отдельном от потока, в котором выполняется основная программа `JS`

Так как программы веб-работников выполняются в отдельном потоке, их взаимодействие с главным потоком приложения ограничивается для предотвращения/ограничения ситуаций гонки и других осложнений. Например, код веб-работников не имеет доступа к `DOM`. Однако некоторые веб-`API` доступны для работников (например, navigator).

Так как веб-работник рассматривается как совершенно отдельная программа, она не имеет общей глобальной области видимости с главной программой `JS`. Однако код все еще выполняется движком  `JS` браузера, поэтому от поведения *глобальной области видимости* можно ожидать аналогичной чистоты. Так как модель `DOM` недоступна, синонима `window` для `глобальной области видимости` не существует.

В коде веб-работника обращение к глобальному объекту обычно осуществляется через `self`:

```js
var studentName = "Kyle";
let studentID = 42;
function hello() {
    console.log(`Hello, ${self.studentName}!`);
}
self.hello(); // Hello, Kyle!
self.studentID; // undefined
```

Как и в главных программах `JS`, объявления `var` и `function` создают зеркальные свойства в `глобальном объекте` (он же `self`), тогда как другие объявления (`let` и т. д.) этого не делают.

Итак, наблюдаемое поведение *глобальной области видимости* практически не уступает по чистоте поведению, наблюдаемому при запуске программ `JS`; возможно, оно даже чище, потому что в нем отсутствует фактор `DOM`, затеняющий ситуацию! 

#### Консоль средств разработчика/REPL

Вспомните, о чем говорилось в главе 1 книги «Познакомьтесь, JavaScript»: средства разработчика не создают полностью интегрированной среды `JS`. Они обрабатывают код `JS`, но также склоняются в пользу *UX*-взаимодействий, наиболее дружественных к разработчикам (*DX*, *Developer eXperience*).

В некоторых случаях особое отношение к *DX* при вводе коротких фрагментов `JS` (вместо обычных формальных действий, ожидаемых при выполнении полной программы `JS`) создает наблюдаемые различия в поведении кода между программами и инструментами. Например, некоторые ситуации ошибок, действующие в программах `JS`, могут ослабляться и не отображаться при вводе кода в средствах разработчика. В контексте нашего обсуждения областей видимости к числу таких наблюдаемых различий могут принадлежать:

- поведение глобальной области видимости;
- поднятие (см. главу 5);
- конструкции объявлений в блоковой области видимости (*let*/ *const*, см. главу 6) при использовании внешней области видимости.

И хотя может показаться, что при использовании консоли/`REPL` команды, введенные во внешней области видимости, обрабатываются в реальной `глобальной области видимости`, это не совсем точно. Такие инструменты обычно до какой-то степени эмулируют `глобальную область видимости`; это именно эмуляция, а не строгое соответствие. Инструментальные среды ставят на первое место удобство разработчика, а это означает, что в отдельных случаях (как в нашем текущем обсуждении областей видимости) наблюдаемое поведение может отклоняться от спецификации `JS`.

Из этого следует, что средства разработчика, оптимизированные для удобства и практичности операций разработки, не могут служить подходящими средами для определения или проверки явных и нетривиальных нюансов поведения в контексте реальных программ `JS`. 

#### Модули ES (ESM)

В `ES6` появилась первоклассная поддержка паттерна «*Модуль*» (см. главу 8). Одно из самых очевидных следствий использования *ESM* связано с изменением поведения наблюдаемой *области видимости* верхнего уровня в файле.

Вспомните фрагмент кода, приводившийся ранее (который будет приведен к формату *ESM* ключевым словом export):

```js
var studentName = "Kyle";
function hello() {
    console.log(`Hello, ${studentName}!`);
}
hello(); // Hello, Kyle!
export hello;
```

Если этот код хранится в файле, который загружается как модуль `ES`, он будет работать точно так же. Но наблюдаемые эффекты с точки зрения приложения в целом будут другими. Несмотря на объявление на верхнем уровне файла (модуля), в наружной области видимости `studentName` и `hello` не являются глобальными переменными. Они существуют на уровне модуля или, если хотите, являются *модульно-глобальными*.

Однако в модуле не существует неявного «*объекта области видимости уровня модуля*», к которому эти объявления верхнего уровня добавлялись бы в виде свойств, как это происходит при размещении объявлений на верхнем уровне файлов `JS`, не являющихся модулями. Это не означает, что в таких программах не могут существовать глобальные переменные или к ним невозможно обратиться. Просто глобальные переменные не создаются объявлением переменных в области верхнего уровня модуля.

*Область видимости верхнего уровня* в модуле происходит от *глобальной области видимости* почти так же, как если бы все содержимое модуля было упаковано в функцию. Таким образом, все переменные, существующие в *глобальной области видимости* (независимо от того, содержатся они в глобальном объекте или нет!), доступны в виде *лексических идентификаторов* из *области видимости модуля*.

*ESM* способствует минимизации зависимости от глобальной области видимости: вы импортируете те модули, которые необходимы для функционирования текущего модуля. Как следствие, в коде реже встречаются случаи использования *глобальной области видимости* или ее *глобального объекта*.

Тем не менее, как упоминалось ранее, остается еще много глобальных элементов `JS` и веб-элементов, к которым вы будете по-прежнему обращаться из *глобальной области видимости* независимо от того, сознаете вы это или нет.

#### Node

У `Node` есть одна особенность, которая часто застает врасплох разработчиков `JS`: Node рассматривает каждый загруженный отдельный файл `.js`, включая главный файл, из которого запускается процесс `Node`, как модуль (модуль ES или модуль Common`JS`, см. главу 8). Практическое следствие заключается в том, что верхний уровень программ `Node` никогда не бывает `глобальной областью видимости` при загрузке в браузере файлов, не являющихся модулями.

На момент написания книги в `Node` недавно появилась поддержка модулей `ES`. Но кроме этого, в `Node` с самого начала поддерживался формат модулей, который обычно называется `Common JS` и выглядит так:

```js
var studentName = "Kyle";
function hello() {
    console.log(`Hello, ${studentName}!`);
}
hello(); // Hello, Kyle!
module.exports.hello = hello;
```

Прежде чем продолжать, `Node` фактически упаковывает такой код в функцию, чтобы объявления `var` и `function` содержались в области видимости функции-обертки, а не считались `глобальными` переменными.

Можно считать, что `Node` воспринимает приведенный код в следующем виде (приводится для пояснения, не как реальный код):

```js
function Module(module, require, __dirname, ...) {
    var studentName = "Kyle";
    function hello() {
        console.log(`Hello, ${studentName}!`);
    }
    hello(); // Hello, Kyle!
    module.exports.hello = hello;
}
```

Затем `Node` фактически вызывает добавленную функцию `Module(..)` для запуска вашего модуля. Здесь четко видно, почему идентификаторы `studentName` и `hello` не являются *глобальными*, а объявлены в области видимости модуля.

Как упоминалось ранее, `Node` определяет ряд глобальных элементов (таких как `require()`), но в действительности они не являются идентификаторами в *глобальной области видимости* (или свойствами `глобального объекта`). Они внедряются в *область видимости* каждого модуля, отчасти напоминая параметры, перечисленные в объявлении функции `Module(..)`

Как же определять реальные *глобальные переменные* в `Node`? Это можно сделать только одним способом: добавлением свойств в другой автоматически представляемый *глобальный элемент* `Node`, который, как ни парадоксально, называется `global. global` содержит ссылку на реальный объект *глобальной области видимости* — нечто вроде window в среде `JS` браузера.
Пример:

```js
global.studentName = "Kyle";
function hello() {
    console.log(`Hello, ${studentName}!`);
}
hello(); // Hello, Kyle!
module.exports.hello = hello;
```

Здесь мы добавляем `studentName` как свойство объекта `global`, после чего в команде `console.log(..)` к` studentName` можно обращаться как к обычной глобальной переменной.

Помните, что `JS` не определяет идентификатор global; он определяется именно Node.

### globalThis

Кратко резюмируя среды `JS`, рассмотренные до настоящего момента, программа может делать (или не делать) следующее:

- объявить глобальную переменную в области видимости верхнего уровня с использованием объявлений `var` и `function` или `let`, `const` и `class`;
- также добавлять объявления глобальных переменных как свойства объекта глобальной области видимости, если для объявления используется ключевое слово `var` или `function`;
- обращаться к объекту глобальной области видимости (для добавления и получения глобальных переменных как свойств) через `window`, `self` или `global`.

Думаю, можно с полным основанием сказать, что поведение *глобальной области видимости* и обращения к ней сложнее, чем считает большинство разработчиков и как было показано в предыдущих разделах. Однако сложность нигде не проявляется так очевидно, как при попытке получить универсально применимую ссылку на объект глобальной области видимости.

Еще один трюк для получения ссылки на объект глобальной области видимости выглядит так:

```js
const theGlobalScopeObject = (new Function("return this"))();
```

>[!info] примечание 
>Функция может быть динамически сконструирована из кода, хранящегося в строковом значении, конструктором `Function()`, сходным с `eval(..)` (см. раздел «`Изменение области видимости во время выполнения`», глава 1). Такая функция будет автоматически выполняться в нестрогом режиме (по соображениям совместимости) при нормальном вызове с использованием механизма `()`; `this` в ней будет указывать на `глобальный объект`. За дополнительной информацией об определении таких привязок обращайтесь к третьей книге серии, «Объекты и классы».

Итак, у нас есть `window`, `self`, `global` и новый безобразный трюк с `new Function(..)`. Много разных способов получения глобального объекта. У каждого есть свои достоинства и недостатки.

Так почему не добавить еще один?!

По состоянию на *ES2020* в `JS` наконец-то появилась стандартизированная ссылка на объект глобальной области видимости, которая называется `globalThis`. Итак, в зависимости от новизны движок `JS`, выполняющих ваш код, вместо всех перечисленных подходов можно использовать `globalThis`.

Можно даже попытаться определить межсредовое полизаполнение, более надежно работающее в средах `JS` до появления `globalThis`:

```js
theGlobalScopeObject = (typeof globalThis != "undefined") ?
    globalThis :
    (typeof global != "undefined") ?
        global :
        (typeof window != "undefined") ?
            window :
            (typeof self != "undefined") ?
                self :
                (new Function("return this"))();
```

Ух! Конечно, такое решение неидеально, но оно работает, если вам потребуется надежная ссылка на *глобальную область видимости*.

Предложенное имя `globalThis` вызвало ожесточенные споры при добавлении этой возможности в `JS`. А именно я и многие другие считали, что ссылка `this` в имени создает неверное впечатление, потому что вы обращаетесь по ссылке на этот объект для того, чтобы получить доступ к *глобальной области видимости*, и никогда — для обращения к некоторой разновидности привязки `this` (глобальной/по умолчанию). Также рассматривалось много других имен, но по различным причинам они были отвергнуты. К сожалению, выбранное имя оказалось последним выходом. Если вы собираетесь взаимодействовать с объектами *глобальной области видимости* в своих программах, то для предотвращения путаницы я настоятельно рекомендую выбрать более понятное имя — например, использованное в данном примере имя `theGlobalScopeObject` (смехотворно длинное, но точное!).

### Глобальная осведомленность

*Глобальная область видимости* присутствует и остается актуальной в каждой программе `JS`, несмотря на то что современные паттерны организации кода по модулям в значительной мере сокращают зависимость от хранения идентификаторов в этом пространстве имен.

Но по мере того как наш код все дальше выходит за рамки браузера, особенно важно хорошо представлять различия в *глобальной области видимости* (и *объекте глобальной области видимости*!) между разными средами `JS`.

Общая картина *глобальной области видимости* немного прояснилась, и в следующей главе мы снова погрузимся в технические подробности *лексической видимости*: как и когда могут использоваться переменные. 
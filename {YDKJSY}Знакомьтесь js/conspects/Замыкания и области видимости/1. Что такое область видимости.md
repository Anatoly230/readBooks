### intro
Вероятно, к тому моменту, когда вы уже написали несколько первых программ, то уже освоились с созданием переменных и хранением в них значений. Работа с переменными — один из фундаментальных навыков в программировании!
Но возможно, вы не уделяли особого внимания механизмам, которые используются движком для организации и управления этими переменными. Я говорю не о выделении памяти компьютером, а совсем о другом: как  `JS` узнает, какие переменные доступны для любой конкретной команды, и как она поступает, обнаруживая две переменные с одинаковыми именами? 
Ответы на подобные вопросы воплощаются в системе четко определенных правил, называемых областью видимости (scope). В этой книге будут подробно рассмотрены все аспекты области видимости — как она работает, для чего она нужна, каких скрытых в ней ловушек стоит остерегаться. После этого будут представлены распространенные паттерны области видимости, определяющие структуру программ.
А начнем мы с описания того, как движок  `JS` обрабатывает наши программы перед запуском. 
### О книге 
Добро пожаловать во вторую книгу серии «Вы пока еще не знаете  `JS`»! Если вы уже прочитали первую книгу «Познакомьтесь, JavaScript», вы на верном пути! Если нет, рекомендую начать с первой книги, которая подготовит вас к этому материалу.
Книга посвящена первому из трех столпов языка  `JS`: системе областей видимости и ее функциональным замыканиям, а также мощному паттерну проектирования «Модуль». 
`JS` обычно относят к категории интерпретируемых языков сценариев, поэтому предполагается, что большинство программ  `JS` обрабатывается за один проход «сверху вниз». Но в действительности  `JS` разбирается/компилируется в отдельной фазе до начала выполнения. Решения автора кода в отношении того, как размещать переменные, функции и блоки относительно друг друга, анализируются с учетом правил области видимости в исходной фазе разбора/компиляции. Полученная структура кода обычно не зависит от условий стадии выполнения. 
Функции  `JS` сами по себе являются полноправными значениями; их можно присваивать и передавать точно так же, как числа или строки. Но так как эти функции содержат переменные и обращаются к ним, они поддерживают свою исходную область видимости независимо от того, в какой точке программы эти функции будут выполняться в конечном итоге. Эта концепция называется замыканием. 
Модули представляют паттерн организации кода, для которого характерны открытые методы с привилегированным доступом (через замыкание) к скрытым переменным и функциям во внутренней области видимости модуля. 
### Компилируемые и интерпретируемые языки
Конечно, вы уже слыхали о компиляции кода. Но скорее всего, процесс компиляции кажется вам чем-то вроде «черного ящика», в который с одного конца подается исходный код, а с другого — выскакивают исполняемые программы.
Но ничего загадочного или волшебного здесь нет. Компиляция кода — последовательность шагов, которая обрабатывает исходный код и преобразует его в набор инструкций, понятных компьютеру. Как правило, весь исходный код преобразуется одновременно, и эти инструкции сохраняются как результат (обычно в файле), который может быть выполнен позднее.
Возможно, вы также слышали, что код может интерпретироваться. Чем же интерпретация отличается от компиляции? 
Интерпретация решает примерно ту же задачу, что и компиляция, — в том смысле, что преобразует вашу программу в набор инструкций, понятных машине. При этом используется другая модель обработки. Если при компиляции обрабатывается сразу вся программа, при интерпретации исходный код преобразуется строка за строкой; после выполнения каждой строки или команды происходит немедленный переход к следующей строке исходного кода.
Являются ли эти две модели обработки взаимоисключающими? В общем случае да. Но проблема скрывает ряд нюансов, потому что интерпретация в действительности может принимать другие формы помимо простой построчной обработки исходного кода.
Современные движки  `JS` в действительности применяют различные сочетания компиляции и интерпретации при обработке программ  `JS`. 
Напомню, что эта тема рассматривалась в главе 1 книги «Познакомьтесь, JavaScript». Там был сделан вывод, что  `JS` точнее всего описывать как компилируемый язык. Для удобства читателей в следующих разделах мы вернемся к этому утверждению и расширим его.

### Компиляция кода

Но для начала необходимо понять, зачем мы вообще говорим о том, компилируется JS или нет? Видимость в основном определяется в фазе компиляции, поэтому понимание связи между компиляцией и выполнением играет ключевую роль для понимания областей видимости. В классической теории компиляторов обработка программы компилятором состоит из трех основных этапов:

>[!info]- Немного теории компиляторов
>Это может быть очевидно, а может быть и удивительно, в зависимости от вашего опыта работы с разными языками, но несмотряна тот факт, что JavaScript относится к общей категории «динамических» или «интерпретируемых» языков, на самом деле это компилируемый язык. Код не компилируется заранее, как во многих традиционных компилируемых языках, а результаты компиляции не портируются между разными распределенными системами. Тем не менее движок JavaScript выполняет многие теже действия, что и любой традиционный компилятор (хотя и на более сложном уровне).В традиционном процессе компиляции блок исходного кода —ваша программа — перед выполнением обычно проходит через три фазы обработки, которые приближенно объединяются термином «компиляция»:
>1. Лексический анализ/Разбиение на токены (Tokenizing/Lexing) —разбиение последовательности символов на осмысленные(с точки зрения языка) фрагменты, называемые токенами. Для примера возьмем программу `var a = 2;`. Скорее всего, эта программа будет разбита на следующие токены: `var, a, =, 2` и `;`.Пропуски могут сохраняться в виде токенов, а могут и не сохраняться в зависимости от того, имеет это смысл или нет. Разница между tokenizing и lexing — вопрос достаточно тонкий и теоретический. Важно то, будет ли происходить идентификация токеном с состоянием или без. Проще говоря, если при вызове токенизатора активизируются правила разбора с состоянием, определяющие, должен ли данный токен считаться отдельным токеном или частью другого токена, это будет называться lexing.
>2. Разбор (parsing) — преобразование потока (массива) токеновв дерево вложенных элементов, которые в совокупности представляют грамматическую структуру программы. Это дерево называется «Абстрактным синтаксическим деревом», или AST(`Abstract Syntax Tree`). Скажем, дерево для `var a = 2`; может начинаться с узла верхнего уровня `VariableDeclaration`, который содержит дочерний узел `Identifier` (со значением `a`) и другой дочерний узел `AssignmentExpression`, у которого есть свой дочерний узел с именем `NumericLiteral` (его значение равно `2`).
>3. Генерирование кода — процесс преобразования AST в исполняемый код. Эта часть сильно зависит от языка, целевой платформы и т. д. Итак, вместо того чтобы вязнуть в подробностях, я просто скажу, что описанное ранее AST-дерево для `var a = 2;` может быть преобразовано в набор машинных команд для создания переменной с именем `a` (включая резервирование памяти и т. д.) и последующего сохранения значения в `a`.

Подробности реализации движка  `JS` (использование ресурсов системной памяти и т. д.) намного глубже, чем мы здесь рассматриваем. Основное внимание будет уделяться наблюдаемому поведению наших программ, а управление более глубокими абстракциями системного уровня будет доверено движку  `JS`.
 
Принципы работы движка  `JS` намного сложнее, они далеко не сводятся только к этим трем стадиям. В процессе разбора и генерирования кода выполняются особые действия для оптимизации быстродействия (например, исключение избыточных элементов). Более того, код даже может быть перекомпилирован и заново оптимизирован в ходе выполнения.
В общем, я привожу только общую картину. Но вскоре вы увидите, почему те подробности, которые здесь рассматриваются (даже на высоком уровне), важны для изучаемой темы. 
Движку  `JS` недоступна такая роскошь, как лишнее время для выполнения их работы и оптимизаций, потому что компиляция  `JS` не выполняется на отдельной стадии до выполнения, как в других языках. Обычно она должна выполняться за считаные микросекунды (или менее!) прямо перед выполнением кода. Чтобы обеспечить наилучшее быстродействие в этих условиях, движок  `JS` использует всевозможные трюки (например, метод JIT с отложенной компиляцией и даже горячей перекомпиляцией); все они выходят за рамки нашего изложения.

### Две фазы

В самой простой формулировке самое важное замечание, которое можно сделать по поводу обработки программ  `JS`, заключается в том, что она выполняется (как минимум) в две фазы: сначала разбор/компиляция, затем выполнение.
Отделение фазы разбора/компиляции от последующей фазы выполнения — наблюдаемый факт, а не какая-то теория или субъективное мнение. Хотя спецификация  `JS` не требует компиляции явно, она требует поведения, которое по сути реально только при подходе «компиляция с последующим выполнением».
Чтобы убедиться в этом, можно понаблюдать за тремя характеристиками программ: синтаксические ошибки, ранние ошибки и поднятие (`hoisting`).

#### Синтаксические ошибки

```js
var greeting = 'Hello';
console.log(greeting);
greeting = . 'HI';
VM5499:3 Uncaught SyntaxError: Unexpected token '.'

```
Программа ничего не выводит (сообщение `"Hello"` не выводится), а вместо этого выдает ошибку `SyntaxError` о неожиданной лексеме `.` прямо перед строкой `"Hi"`. Так как синтаксическая ошибка происходит после правильно сформированной команды` console. log(..)`, если бы код `JS` выполнялся при построчном выполнении программы сверху вниз, можно было бы ожидать, что сообщение `"Hello"` будет выведено перед выдачей синтаксической ошибки. Но этого не происходит.
>[!tip] Важное замечание
>Движок `JS` может узнать о синтаксической ошибке в третьей строке, перед выполнением первой и второй строк, только в одном случае: если движок  `JS` сначала разбирает всю программу до того, как будет выполнена любая из ее частей.

#### Ранние ошибки

```js
console.log('Howdy');
saySomeThing('hello', 'HI')
function saySomeThing(greeting,greeting){
'use strict'
console.log(greeting)
}
VM6532:3 Uncaught SyntaxError: Duplicate parameter name not allowed in this context

```

Сообщение "Howdy" не выводится, несмотря на правильно сформированную команду.
Вместо этого, как и во фрагменте из предыдущего раздела, перед выполнением программы выдается ошибка SyntaxError. В данном случае это объясняется тем, что строгий режим (включенный только для функции `saySomething(..))` запрещает среди прочего функции с одинаковыми именами параметров; в нестрогом режиме это всегда было разрешено.
Выданная ошибка не является синтаксической ошибкой, обусловленной неправильно сформированной последовательностью лексем (как ."Hi" выше), но в строгом режиме спецификация требует выдавать раннюю ошибку до начала выполнения.
Но как движок  `JS` узнает, что параметр greeting повторяется? Откуда он знает, что функция `saySomething(..)` выполняется в строгом режиме во время обработки списка параметров (директива `"use strict"` появляется позже в теле функции)?
И снова возможно только одно разумное объяснение: код полностью разбирается до начала выполнения.

#### Поднятие

Наконец, рассмотрим пример:

```js
function saySomething() {
var greeting = "Hello";
{
greeting = "Howdy"; // здесь происходит ошибка
let greeting = "Hi";
console.log(greeting);
}
}
undefined
saySomething()
VM6938:4 Uncaught ReferenceError: Cannot access 'greeting' before initialization
    at saySomething (<anonymous>:4:10)
    at <anonymous>:1:1
saySomething @ VM6938:4
(anonymous) @ VM6944:1

```

Источником ошибки ReferenceError является строка с командой `greeting = "Howdy"`. Дело в том, что переменная greeting из этой команды относится к объявлению в следующей строке `let greeting = "Hi"`, а не к предыдущей команде `var greeting = "Hello"`.
В строке, в которой выдается ошибка, движок `JS` может только в одном случае узнать о том, что следующая команда объявляет одноименную переменную (`greeting`) с блоковой видимостью: если движок `JS` уже обработал этот код на более раннем проходе и уже сформировал все области видимости и их связи с переменными. Такая обработка областей видимости и объявлений может быть достигнута только при обработке программы перед выполнением.
С технической точки зрения ошибка `ReferenceError` происходит из-за того, что команда `greeting = "Howdy"` обращается к переменной greeting слишком рано — этот конфликт обозначается сокращением `TDZ (Temporal Dead Zone)`. В главе 5 эта тема рассматривается более подробно.

>[!warning] Примечание 
>  Часто встречаются утверждения о том, что объявления `let` и `const` не поднимаются, как показывает только что приведенное объяснение поведения `TDZ`. Тем не менее это неточное утверждение. Мы еще вернемся к темам поднятия и `TDZ` для конструкций let/const в главе 5.

Надеюсь, я убедил вас в том, что программы  `JS` разбираются до начала какого-либо выполнения. Но доказывает ли это, что они компилируются?

И это интересный вопрос. Может ли `JS` разобрать программу, но затем выполнить ее с интерпретацией операций, представленных в `AST`, без ее предварительной компиляции? Да, это возможно. Но в высшей степени маловероятно, прежде всего потому, что это будет крайне неэффективно с точки зрения быстродействия. Трудно представить себе, что движок `JS` коммерческого уровня пойдет на все хлопоты с разбором программы в `AST`, но без последующего преобразования (компиляции) полученного дерева `AST` в самое эффективное (двоичное) представление для его последующего выполнения движком.
Многие придираются к этой терминологии, так как в этой области встречается множество нюансов и замечаний «хотя вообще-то…». Однако по духу и на практике то, что делает движок при обработке программ  `JS`, имеет с компиляцией гораздо больше общего, чем с чем-либо другим.
Классификация  `JS` как компилируемого языка не имеет отношения к модели распространения в двоичном исполняемом представлении (или в байт-коде). Скорее она всего лишь четко выделяет в нашем мысленном представлении фазу, в которой обрабатывается и анализируется код  `JS`; эта фаза наблюдаемо и бесспорно выполняется до начала выполнения кода. Если мы хотим понимать и эффективно использовать `JS` и области видимости, понадобятся подходящие ментальные модели того, как движок  `JS` обходится с нашим кодом.

### С точки зрения компилятора

Зная о двухфазной обработке программы  `JS` (сначала компиляция, потом выполнение), обратимся к тому, как движок  `JS` идентифицирует переменные и определяет области видимости в программе в процессе компиляции.
Сначала рассмотрим простую программу JS, которая будет использоваться для анализа в нескольких ближайших главах:

```js
var students = [
{ id: 14, name: "Kyle" },
{ id: 73, name: "Suzy" },
{ id: 112, name: "Frank" },
{ id: 6, name: "Sarah" }
];
function getStudentName(studentID) {
for (let student of students) {
if (student.id == studentID) {
return student.name;
}
}
}
var nextStudent = getStudentName(73);
console.log(nextStudent);
VM9381:15 Suzy
undefined

```

Кроме объявлений, все вхождения переменных/идентификаторов в программе играют одну из двух ролей: они являются либо приемником присваивания, либо источником значения.
> [!tip] Важно
> Когда я только начал изучать теорию компиляторов для получения диплома `computer science`, в ней для этих ролей использовались термины `LHS` (приемник) и `RHS` (источник) соответственно. Эти сокращения происходят от `Left-Hand Side` и `Right-Hand Side` — для левой и правой сторон оператора присваивания `=`. Однако приемники и источники присваивания не всегда буквально располагаются слева и справа от `=`, поэтому я предпочитаю термины «приемник/источник» вместо «левый/правый».

Как узнать, является ли переменная приемником? Проверьте, присваивается ли ей значение; если присваивается, то это приемник. Если нет, то переменная является источником.
Чтобы движок JS правильно обрабатывал переменные в программе, он должен сначала пометить каждое вхождение переменной как приемник или как источник. Сейчас мы разберемся, как определяется каждая из этих ролей.

#### Приемники

Что делает переменную приемником? Пример:
```js
students = [ // ..
```

Эта команда очевидно является операцией присваивания; помните, что часть `var students` полностью обрабатывается как объявление во время компиляции, а следовательно, не актуальна во время выполнения; мы опустили ее для ясности. То же относится к команде `nextStudent = getStudentName(73)`.
Но есть еще три менее очевидные операции, использующие приемник присваивания. Одна из них:
```js
for (let student of students) {
```

Эта команда присваивает значение `student` при каждой итерации цикла. Другая ссылка на приемник:
```js
getStudentName(73)
```
Но каким образом это является присваиванием? Присмотритесь внимательнее: аргумент `73` присваивается параметру `studentID`.

И в нашей программе осталась последняя (неочевидная) ссылка на приемник.
А вы сможете ее найти?

```js
function getStudentName(studentID) {
```

Объявление функции является специальным случаем ссылки на приемник. Ее можно рассматривать как нечто похожее на `var getStudentName = function(studentID)`, но это не совсем точно.
Идентификатор `getStudentName` объявляется во время компиляции, но часть `=` `function(studentID)` также обрабатывается в процессе компиляции; связь между `getStudentName` и функцией автоматически создается в начале области видимости, вместо того чтобы ожидать выполнения команды присваивания `=`.

>[! info] Примечание
>Автоматическое связывание функции с переменной называется поднятием функции (`function hoisting`). Эта тема подробно рассматривается в главе 5.

#### Источники
Итак, мы выявили все пять ссылок на приемник в программе. Тогда все остальные ссылки на переменные должны быть ссылками на источники (потому что других вариантов нет).
Мы выяснили, что в `for (let student of students)` переменная `student` является ссылкой на приемник, а `students` — ссылкой на источник. В команде `if (student.id == studentID)` и` student`, и `studentID` являются ссылками на источник. `student` также является ссылкой на источник в команде `return student.name`.
В `getStudentName(73)` переменная `getStudentName` является ссылкой на источник (которая, как мы надеемся, будет преобразована в значение ссылки на функцию). В команде `console.log(nextStudent)` переменная `console` является ссылкой на источник, как и `nextStudent`.

> [!info] Примечание
> Если вас интересует, `id`, `name` и `log` — свойства, а не ссылки на переменные.

В чем практический смысл разделения приемников и источников? В главе 2 мы вернемся к этой теме и посмотрим, как роль переменной влияет на последствия ее поиска (а именно если поиск завершается неудачей).

### Изменение области видимости во время выполнения

К настоящему моменту должно быть уже ясно, что область видимости определяется при компиляции программы и обычно не должна зависеть от условий на стадии выполнения. Тем не менее в нестрогом режиме технически это правило можно обойти двумя способами, изменяя области видимости программы во время выполнения.
Ни один из этих приемов не следует применять на практике — оба слишком опасны и слишком запутанны, и вам все равно стоит использовать строгий режим (в котором они запрещены). Но важно знать о них на тот случай, если вы столкнетесь с ними в каких-нибудь программах.
Функция `eval(..)` получает строку с кодом, который должен быть откомпилирован и выполнен «на ходу», во время выполнения программы. Если эта строка кода содержит var или объявление функции, эти объявления изменят текущую область видимости, в которой в настоящее время выполняется `eval(..)`:

```js
function badIdea() {
eval("var oops = 'Ugh!';");
console.log(oops);
}
badIdea(); // Ugh!
```
Если бы вызов `eval(..)` отсутствовал, то переменная `oops` в `console.log(oops)` не существовала бы и программа выдала бы ошибку ReferenceError. Однако `eval(..)` изменяет область видимости функции `badIdea()` во время выполнения. Это нежелательно по многим причинам, включая снижение быстродействия из-за модификации уже откомпилированной и оптимизированной области видимости при каждом запуске `badIdea()`.
Второй трюк основан на использовании ключевого слова `with`, которое, по сути, динамически преобразует объект в локальную области видимости — его свойства интерпретируются как идентификаторы в блоке новой области видимости:

```js
var badIdea = { oops: "Ugh!" };
with (badIdea) {
console.log(oops); // Ugh!
}
```

Глобальная область видимости здесь не изменяется, но объект `badIdea` приводится в область видимости во время выполнения, а не во время компиляции, а его свойство `oops` превращается в переменную в этой области видимости. Еще раз подчеркну: это очень плохая идея по соображениям быстродействия и удобочитаемости.

Всеми силами избегайте `eval(..)` (по крайней мере, `eval(..)` с созданием объявлений) и `with`. Напомню, что ни один из этих трюков не доступен в строгом режиме, и если вы просто используете строгий режим (а это стоит делать!), искушение пропадет само собой.
#### Лексические области видимости

Мы показали, что область видимости JS определяется на стадии компиляции; такая разновидность областей видимости называется лексической областью видимости. Определение «лексический» относится к фазе лексического разбора процесса компиляции, как обсуждалось ранее в этой главе.
Чтобы свести эту главу к одному полезному выводу, ключевая идея лексической области видимости заключается в том, что она полностью определяется размещением функций, блоков и объявлений переменных относительно друг друга
Если объявление переменной размещается внутри функции, компилятор обрабатывает его в процессе разбора функции и связывает это объявление с областью видимости функции. Если переменная объявлена с блоковой областью видимости (`let/const`),то она связывается с ближайшим вмещающим блоком {..} вместо вмещающей функции (как с ключевым словом `var`).
Более того, ссылка на переменную (в роли приемника или источника) должна разрешаться как поступившая одной из областей видимости, которая доступна ей на лексическом уровне; в противном случае говорят, что переменная не объявлена (что обычно приводит к ошибке!). Если переменная не объявлена в текущей области видимости, то проверяется следующая внешняя/вмещающая область видимости. Процесс перехода на один уровень области видимости продолжается до тех пор, пока не будет найдено подходящее объявление переменной или не будет достигнута глобальная область видимости, и дальше идти уже некуда.
Важно заметить, что при компиляции не выполняются никакие реальные операции, связанные с резервированием памяти для областей видимости и переменных. Ни одна команда в программе еще не выполнена.
Вместо этого процесс компиляции строит план всех лексических областей видимости. Эта структура данных определяет, что потребуется программе во время ее выполнения. Можно рассматривать этот план как кодовую вставку, используемую во время выполнения, в которой определяются все области видимости (лексическое окружение) и регистрируются все идентификаторы (переменные) для каждой области видимости.
Иначе говоря, хотя области видимости определяются во время компиляции, их фактическое создание откладывается до стадии выполнения. В следующей главе будут кратко описаны концеп
туальные основания лексической видимости.
### Введение

Эта глава завершается рассмотрением одного из важнейших паттернов организации кода во всем программировании — модулей. Как вы увидите, модули по своей сути строятся на том материале, который приводился ранее: ваши усилия по изучению лексической видимости и замыканий окупятся лишний раз. 

Мы рассмотрели все тонкости лексической видимости, от широты глобальной области видимости до глубин вложенных блоковых областей и тонкостей жизненного цикла переменных. Затем концепция лексической видимости была использована для представления всей мощи замыканий. 

Выделите немного времени и поразмыслите над тем, как далеко вы зашли в своем путешествии; вы упорно шли вперед, чтобы лучше узнать JS! 

Центральная тема этой книги заключается в том, что понимание и уверенное владение областями видимости и замыканиями играют ключевую роль в правильном структурировании и организации вашего кода, особенно в решениях относительно того, где следует хранить информацию в переменных.

В этой последней главе я покажу, как модули воплощают важность этих тем, поднимая их от абстрактных концепций до конкретных, практических усовершенствований при построении программ. 

### Инкапсуляция и принцип наименьшего раскрытия (POLE)

Инкапсуляция часто представляется как принцип объектно-ориентированного (ОО) программирования, но это намного более фундаментальная концепция, находящая широкое практическое применение. Цель инкапсуляции — упаковка, т. е. совместное размещение, информации (данных) и поведения (функций), служащих общей цели. 

Независимо от синтаксиса или программных механизмов в простейшем виде суть инкапсуляции можно представить как использование отдельных файлов для хранения частей общей программы, объединенных единым предназначением. Если упаковать все, что относится к списку результатов поиска, в один файл с именем search-list.js, вы тем самым инкапсулируете эту часть программы. 

Последние тенденции в современном фронтенд-программировании к организации приложений на базе компонентной архитектуры способствуют еще более широкому применению инкапсуляции. Для многих разработчиков кажется естественным объединить все, что относится к списку результатов поиска (не только код, но и разметку представления и стилевое оформление), в единицу программной логики — иногда вполне материальную, с которой можно взаимодействовать. И затем мы называем этот набор компонентом SearchList. 

Другая ключевая цель — управление видимостью некоторых аспектов инкапсулированных данных и функциональности. Вспомните принцип наименьшего раскрытия (POLE) из главы 6, направленный на защиту от различных рисков чрезмерного раскрытия областей видимости; эти риски распространяются как на переменные, так и на функции. В JS управление видимостью обычно реализуется через механизм лексической области видимости. 

Идея заключается в том, чтобы сгруппировать взаимосвязанные части программы и избирательно ограничить программный доступ к тем частям, которые мы считаем приватными подробностями реализации. Те части, которые не считаются приватными, помечаются как открытые и доступные для всей программы. 

Естественным следствием такой работы становится улучшение организации кода. Программный продукт проще строить и сопровождать, если вы знаете, где что находится, с четкими и очевидными границами и точками соединения. Также вам будет проще обеспечивать качество кода, если вы будете избегать опасностей чрезмерного раскрытия данных и функциональности.
### Что такое модуль?

Модуль представляет собой набор взаимосвязанных данных и функций (часто называемых методами в этом контексте), характеризуемых четким разделением между приватными подробностями реализации и открытыми аспектами, обычно называемыми открытым API. 

Модуль также обладает состоянием: он поддерживает некоторую информацию во времени вместе с функциональностью для чтения и обновления этой информации.

> [!info] Примечание
> В более широком смысле паттерн «Модуль» обеспечивает модуляризацию на системном уровне за счет слабых связей и других средств программной архитектуры. Это сложная тема, выходящая за рамки нашего обсуждения, но она заслуживает того, чтобы вы самостоятельно изучили ее.

Чтобы вы лучше поняли, что такое модуль, сравним некоторые характеристики модулей с полезными паттернами программирования, которые модулями не являются. 

#### Пространства имен (группировка без состояния) 

Если вы группируете несколько взаимосвязанных функций без данных, то такая группировка не обеспечивает той инкапсуляции, которую подразумевают модули. Для подобной группировки функций без состояния существует специальный термин — «пространство имен»:

```js
// namespace, not module
var Utils = {
    cancelEvt(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        evt.stopImmediatePropagation();
    },
    wait(ms) {
        return new Promise(function c(res){
            setTimeout(res,ms);
        });
    },
    isValidEmail(email) {
        return /[^@]+@[^@.]+\.[^@.]+/.test(email);
    }
};
```

Utils — полезный набор вспомогательных функций, но все эти функции не зависят от состояния. Группировка функциональности обычно является полезной практикой, но от этого она не становится модулем. Вместо этого мы определили пространство имен Utils и упорядочили в нем функции. 

#### Структуры данных (группировка с состоянием) 

Даже если вы группируете данные вместе с функциями, обладающими состоянием, но не ограничиваете их видимости, вы не достигаете аспекта инкапсуляции, определяемого принципом наименьшего раскрытия (POLE); вряд ли полученная конструкция заслуживает название «модуль».

Пример:

```js
// data structure, not module
var Student = {
    records: [
        { id: 14, name: "Kyle", grade: 86 },
        { id: 73, name: "Suzy", grade: 87 },
        { id: 112, name: "Frank", grade: 75 },
        { id: 6, name: "Sarah", grade: 91 }
    ],
    getName(studentID) {
        var student = this.records.find(
            student => student.id == studentID
        );
        return student.name;
    }
};

Student.getName(73);
// Suzy
```

Так как records содержит общедоступные данные, не скрытые ни за каким открытым API, Student в действительности не является модулем. 

Student обладает аспектом данные + функциональность, присущим инкапсуляции, но не обладает аспектом управления видимостью. Для таких случаев лучше подходит термин «структура данных».

#### Модули (управление доступом с состоянием) 

Чтобы дух паттерна «Модуль» воплотился в полной мере, понадобятся не только группировка и состояние, но и управление доступом через видимость (приватные/открытые части). Преобразуем структуру Student из предыдущего раздела в модуль. Начнем с формы, которую я называю классическим модулем (когда она только появилась в начале 2000-х, изначально использовался термин «модуль с управлением видимостью»). Пример:

```js
var Student = (function defineStudent(){
    var records = [
        { id: 14, name: "Kyle", grade: 86 },
        { id: 73, name: "Suzy", grade: 87 },
        { id: 112, name: "Frank", grade: 75 },
        { id: 6, name: "Sarah", grade: 91 }
    ];

    var publicAPI = {
        getName
    };

    return publicAPI;

    // ************************

    function getName(studentID) {
        var student = records.find(
            student => student.id == studentID
        );
        return student.name;
    }
})();

Student.getName(73);   // Suzy
```

Здесь структура Student является примером модуля. Она предоставляет открытый API с единственным методом getName(..). Этот метод обращается к приватным скрытым данным records.

>[!info] Примечание
>Должен указать, что данные студентов, явно запрограммированные в этом определении модуля, приведены только для наглядности. Типичный модуль в вашей программе получает данные из внешнего источника — обычно из баз данных, файлов данных JSON, вызовов Ajax и т. д. Затем эти данные внедряются в экземпляр модуля (как правило, методами открытого API модуля). 

#### Как работает классический формат модулей?

Обратите внимание: экземпляр модуля создается выполняемым IIFE defineStudent(). IIFE возвращает объект (с именем publicAPI), который содержит свойство со ссылкой на внутреннюю функцию getName(..). 

Присваивание объекту имени publicAPI определяется моими стилистическими предпочтениями. Объекту можно присвоить любое имя на ваш выбор (для JS это никакой роли не играет) или вы можете вернуть объект напрямую без присваивания внутренней именованной переменной. Подробнее этот выбор рассматривается в приложении А.

С внешней точки зрения Student.getName(..) вызывает эту предоставленную внутреннюю функцию, которая сохраняет доступ к внутренней переменной records через замыкание. 

Вы не обязаны возвращать объект, одним из свойств которого является функция. Также функцию можно вернуть напрямую, вместо объекта — все основные составляющие классического модуля при этом сохраняются.

Из-за особенностей работы лексических областей видимости определения переменных и функций внутри функции определения внешнего модуля по умолчанию становятся приватными. Только свойства, добавленные в открытый объект API, возвращаемый функцией, будут экспортированы для внешнего открытого использования. 

Использование IIFE подразумевает, что программе понадобится только один центральный экземпляр модуля — такой экземпляр обычно называется одиночкой (singleton). Рассмотренный пример достаточно прост, и нет никаких очевидных причин, из-за которых программе могли бы потребоваться сразу несколько экземпляров модуля Student. 

#### Фабрика модулей (множественные экземпляры)

Но что, если вы хотите определить модуль, который может существовать в программе в нескольких экземплярах? В таком случае придется слегка изменить код:

```js
// factory function, not singleton IIFE
function defineStudent() {
    var records = [
        { id: 14, name: "Kyle", grade: 86 },
        { id: 73, name: "Suzy", grade: 87 },
        { id: 112, name: "Frank", grade: 75 },
        { id: 6, name: "Sarah", grade: 91 }
    ];

    var publicAPI = {
        getName
    };

    return publicAPI;

    // ************************

    function getName(studentID) {
        var student = records.find(
            student => student.id == studentID
        );
        return student.name;
    }
}

var fullTime = defineStudent();
fullTime.getName(73);    
// Suzy
```

Чтобы не определять defineStudent() в форме IIFE, мы просто определяем обычную автономную функцию, которая в данном контексте обычно называется фабрикой модулей. 

Затем программа вызывает фабрику модулей для создания экземпляра модуля, которому присваивается имя fullTime. Этот экземпляр модуля подразумевает создание нового экземпляра внутренней области видимости, а следовательно, нового замыкания, в котором getName(..) удерживает records. Теперь fullTime. getName(..) вызывает метод для этого конкретного экземпляра.

#### Определение классического модуля 

Итак, какими же признаками должен обладать классический модуль?
Должна существовать внешняя область видимости — обычно от функции-фабрики модулей, выполняемой хотя бы один раз. 
Внутренняя область видимости модуля должна содержать хотя бы один блок скрытой информации, представляющей состояние модуля.\
Модуль должен возвращать через свой открытый API ссылку на хотя бы одну функцию, которая содержит замыкание на скрытое состояние модуля (чтобы это состояние сохранялось после вызова). 

Вероятно, вы столкнетесь с другими вариациями на тему классических модулей, которые будут более подробно рассмотрены в приложении А.

### Модули Node CommonJS

В главе 4 был представлен формат модулей CommonJS, используемых Node. В отличие от формата классических модулей, описанного выше, в котором вы можете упаковать фабрику модулей или IIFE наряду с любым другим кодом, включая другие модули, модули CommonJS соответствуют файлам — один модуль на файл.

Изменим наш пример модуля, чтобы он соответствовал этому формату:

```js
module.exports.getName = getName;

// ************************

var records = [
    { id: 14, name: "Kyle", grade: 86 },
    { id: 73, name: "Suzy", grade: 87 },
    { id: 112, name: "Frank", grade: 75 },
    { id: 6, name: "Sarah", grade: 91 }
];

function getName(studentID) {
    var student = records.find(
        student => student.id == studentID
    );
    return student.name;
}
```

Идентификаторы records и getName принадлежат области видимости верхнего уровня этого модуля, но не глобальной области видимости (см. главу 4). Как следствие, все составляющие по умолчанию являются приватными для этого модуля.

Чтобы открыть доступ к чему-либо через открытый API в модуле CommonJS, мы добавляем свойство в пустой объект, предоставляемый в виде module.exports. В старом унаследованном коде вам могут встретиться ссылки, в которых используется только exports, но для ясности кода всегда следует уточнять эту ссылку префиксом module. 

По стилистическим соображениям я предпочитаю размещать exports в начале, а реализацию модуля — в конце файла. При этом команды с exports можно размещать где угодно. Настоятельно рекомендую группировать их в начале или конце файла. 

Некоторые разработчики привыкли заменять объект exports по умолчанию:

```js
// defining a new object for the API
module.exports = {
    // ..exports..
};
```

У такого подхода есть некоторые нежелательные странности, включая непредсказуемое поведение при циклических зависимостях между модулями. По этой причине не рекомендую использовать замену объекта. Если вы хотите назначить сразу несколько элементов экспортирования одновременно, используя определение в стиле объектных литералов, это можно сделать так:

```js
Object.assign(module.exports,{
   // .. exports ..
});
```

Что здесь происходит? При определении объектного литерала {..} с указанием открытого API вашего модуля с последующим Object.assign(..) происходит поверхностное копирование всех этих свойств в существующий объект module.exports вместо его замены. Такое решение хорошо сочетает удобство с более безопасным поведением модуля. 

Чтобы включить в модуль/программу другой экземпляр модуля, используйте метод Node require(..). Если предположить, что этот модуль находится в файле /path/to/student.js, к нему можно обратиться следующим образом:

```js
var Student = require("/path/to/student.js");

Student.getName(73);
// Suzy
```

После этого Student ссылается на открытый API модуля из нашего примера. 

Модули CommonJS ведут себя как одиночные экземпляры по аналогии со стилем определения модулей IIFE, описанным ранее. Сколько бы раз вы ни вызывали require(..) для одного модуля, вы будете просто получать дополнительные ссылки на один общий экземпляр модуля. 

Механизм require(..) работает по принципу «все или ничего»; он включает ссылку на весь предоставляемый открытый API модуля. Если вам нужно обратиться только к части API, типичное решение выглядит так:

```js
var getName = require("/path/to/student.js").getName;

// or alternately:

var { getName } = require("/path/to/student.js");
```

По аналогии с форматом классических модулей явно экспортируемые методы API модуля CommonJS удерживают замыкания на внутренние подробности модулей. Так состояние модуля (одиночный экземпляр) поддерживается на протяжении жизненного цикла программы.

>[!info] Примачание
>В командах Node require("student") неабсолютные пути ("student") предполагают расширение .js и проводят поиск в node_modules

### Современные модули ES (ESM)

Формат ESM в чем-то напоминает формат CommonJS. Он также базируется на файлах, экземпляры модулей являются одиночными, и по умолчанию все части считаются приватными. Одно заметное различие заключается в том, что файлы ESM всегда работают в строгом режиме и не требуют включения директивы "use strict" в начало файла. Модули ESM невозможно определить так, чтобы они выполнялись в нестрогом режиме. 

Вместо module.exports в CommonJS ESM использует ключевое слово export для предоставления доступа к элементам через открытый API модуля. Ключевое слово import заменяет команду require(..). Отредактируем students.js для использования формата ESM:

```js
export { getName };

// ************************

var records = [
    { id: 14, name: "Kyle", grade: 86 },
    { id: 73, name: "Suzy", grade: 87 },
    { id: 112, name: "Frank", grade: 75 },
    { id: 6, name: "Sarah", grade: 91 }
];

function getName(studentID) {
    var student = records.find(
        student => student.id == studentID
    );
    return student.name;
}
```

Единственное изменение — команда export getName. Как и в предыдущем случае, команды export могут находиться в любой позиции файла, хотя команда export должна находиться в области видимости верхнего уровня; она не может располагаться внутри любого другого блока или функции. 

ESM поддерживает разные формы записи команд export в ESM. Пример: 

```js
export function getName(studentID) {
    // ..
}
```

Хотя ключевому слову function предшествует export, эта форма остается объявлением функции, которая также дополнительно экспортируется. А именно идентификатор getName поднимается как функция (см. главу 5), поэтому он доступен во всей области видимости модуля.

Другой возможный вариант:

```js
export default function getName(studentID) {
    // ..
}
```

Это так называемое экспортирование по умолчанию, которое отличается семантикой от других видов экспортирования. В сущности, экспортирование по умолчанию представляет собой сокращенную форму для потребителей модуля. Это более компактный синтаксис для тех, кому нужен только один элемент API по умолчанию.

Экспортируемые элементы, которые не экспортируются по умолчанию, называются именованными. 

Ключевое слово import — как и export, оно должно использоваться только на верхнем уровне ESM за пределами любых блоков или функций — также существует в нескольких синтаксических разновидностях. Первый вариант называется именованным импортированием:

```js
import { getName } from "/path/to/students.js";
getName(73); // Suzy
```

Как видите, эта форма импортирует из модуля только открытые элементы API с указанными именами (все, что не указано явно, пропускается). Эти идентификаторы добавляются в область видимости верхнего уровня текущего модуля. Такая разновидность импортирования знакома всем, кто пользовался пакетным импортированием в таких языках, как Java. В фигурных скобках {..} можно перечислить несколько элементов API, разделяя их запятыми. Именованный импортируемый элемент также можно переименовать при помощи ключевого слова as: 

```js
import { getName as getStudentName } from "/path/to/students.js";
getStudentName(73); // Suzy
```

Если функция getName является экспортированием по умолча нию для модуля, его можно импортировать следующим обра зом:

```js
import getName from "/path/to/students.js";
getName(73);   // Suzy
```

Единственное отличие — отсутствие { } вокруг импортируемого элемента. Если вы хотите смешать импортирование по умолчанию с другими именованными импортируемыми элементами, это делается так:

```js
import { default as getName, /* .. others .. */ } from "/path/to/students.js";
getName(73);   // Suzy
```

Следующая форма импортирования называется импортированием пространства имен:

```js
import * as Student from "/path/to/students.js";
Student.getName(73);   // Suzy
```

Наверное, это очевидно, но символ * импортирует все экспортируемые элементы API (как по умолчанию, так и именованные) и сохраняет их под одним заданным идентификатором пространства имен. Такой подход ближе всего соответствует форме классических модулей, которые поддерживались на протяжении большей части истории JS.

>[!info] Примечание
>На момент написания книги современные браузеры поддерживали ESM уже несколько лет, но более или менее стабильная поддержка ESM в Node появилась относительно недавно и с тех пор прошла довольно значительный путь. Вероятно, эволюция будет продолжаться вближайшие годы; включение поддержки ESM в ES6 создало ряд нетривиальных проблем совместимости с системой взаимодействия с модулями CommonJS в Node. За всеми последними подробностями обращайтесь к документации ESM в Node: https://nodejs.org/api/esm.html

### На выходе из области видимости

Независимо от того, какой формат вы используете — классический формат модулей (браузер или Node), формат CommonJS (в Node) или ESM (браузер или Node), модули остаются одним из самых эффективных способов структурирования и организации функциональности и данных вашей программы. 

Паттерн «Модуль» завершает наше путешествие по этой книге. Вы учились применять правила лексических областей видимости для размещения переменных и функций в правильных позициях. Принцип наименьшего раскрытия диктует защитный подход приватности по умолчанию, с которым вы избегаете чрезмерного раскрытия и взаимодействуете только с минимально необходимой поверхностью открытого API. 

А если заглянуть на более низкий уровень, магия с хранением состояния модулей основывается на замыканиях, использующих систему лексических областей видимости. 

На этом основная часть книги завершается. Поздравляю, вы прошли долгий путь! Как я говорил уже не раз, сейчас самое время сделать паузу, поразмыслить и потренироваться в применении того, что вы узнали.
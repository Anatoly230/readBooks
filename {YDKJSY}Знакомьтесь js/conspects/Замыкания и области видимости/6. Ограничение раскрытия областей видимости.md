### Введение

До сих пор наше внимание было направлено на объяснение механики того, как работают *области видимости* и *переменные*. Теперь, когда мы усвоили эту тему, можно подняться на более высокий уровень абстракции: *решения и паттерны*, применяемые в программах в целом. Для начала посмотрим, как и почему стоит использовать разные уровни *областей видимости* (*функции и блоки*) для организации переменных программы и конкретно для сокращения чрезмерного раскрытия *областей видимости*.
### Принцип наименьшего раскрытия

 Вполне логично, что функции определяют собственные *области видимости*. Но почему блоки тоже должны создавать *области видимости*? 
 
 В программировании сформулирован фундаментальный принцип, который обычно применяется в области безопасности ПО, — принцип наименьших привилегий ( [^1]*POLP, Principle of Least Privilege*). А разновидность этого принципа, применяемая к нашему текущему обсуждению, обычно называется принципом наименьшего раскрытия (*POLE, Principle of Least Exposure*). 
 
 Принцип наименьших привилегий выражает защитную позицию программной архитектуры: компоненты системы должны проектироваться так, чтобы они функционировали с наименьшими привилегиями, наименьшим уровнем доступа и наименьшим раскрытием. Если каждый компонент соединяется с другими с минимальными необходимыми возможностями, система в целом становится сильнее с точки зрения безопасности, потому что сбой или взлом одного компонента минимально влияет на остальные части системы. 
 
 Если принцип наименьших привилегий направлен на проектирование компонентов на уровне системы, *принцип наименьшего раскрытия* сосредоточен на более низком уровне; мы применим его к взаимодействиям между *областями видимости*. 
 
 Если следовать *принципу наименьшего раскрытия*, что именно должно раскрываться в наименьшей степени? Очень просто: *переменные*, зарегистрированные в *каждой области видимости*. На это можно взглянуть так: почему не стоит размещать все переменные программы в *глобальной области видимости*? Наверное, вы и так чувствуете, что это неудачная идея, но стоит разобраться почему. Когда переменные, используемые одной частью программы, раскрываются для другой части через *область видимости*, часто возникают *три главных фактора риска*.

- **Конфликты имен**: если вы используете стандартное содержательное имя переменной/функции в двух разных частях программы, но идентификатор происходит из одной общей *области видимости* (например, глобальной), возникает конфликт имен и очень вероятно, что использование одной частью переменной/ функции способом, неожиданным для другой части, приведет к ошибке. 
  Например, представьте, что все ваши циклы используют одну глобальную переменную цикла *i*. Цикл из одной функции выполняется во время итерации цикла из другой функции, и общей переменной *i* присваивается неожиданное значение.
- **Неожиданное поведение**: если вы раскроете переменные/ функции, использование которых должно быть приватным для некоторой части программы, это позволит другим разработчикам использовать их непредвиденным образом. Это приведет к нарушению ожидаемого поведения и появлению ошибок. 
  Например, если ваша часть программы предполагает, что массив содержит только числа, но чей-то посторонний код обратится к массиву и включит в него логические значения и строки, это может привести к непредвиденным сбоям в вашем коде. 
  Что еще хуже, раскрытие приватных подробностей подталкивает злоумышленника к попытке обойти ваши ограничения и использовать вашу программу запрещенным способом.
- **Непреднамеренная зависимость**: раскрывая переменные/ функции без необходимости, вы подталкиваете других разработчиков к тому, чтобы использовать эти в остальном приватные части и зависеть от них. И хотя сейчас работоспособность вашей программы от этого не пострадает, в будущем вы уже не сможете легко провести рефакторинг без риска нарушить работоспособность других частей продукта, которые не контролируете. 
  Например, если ваш код зависит от числового массива, а позднее вы решите, что вместо массива лучше использовать другую структуру данных, то тем самым принимаете на себя ответственность за соответствующее изменение других частей продукта.

Применительно к *областям видимости* переменных/функций принцип наименьшего раскрытия фактически говорит: *по умолчанию раскрытие должно ограничиваться абсолютным минимумом, а все остальное должно остаться приватным настолько, насколько это возможно*. Объявляйте переменные в *областях видимости* наименьшего размера и наибольшего уровня вложенности, вместо того чтобы размещать все в глобальной области видимости (или даже внешней функции).

Если вы спроектируете свою программу соответствующим образом, у вас будет намного больше возможностей для предотвращения этих трех рисков (или, по крайней мере, сведения их к минимуму). 

Пример:

```js
function diff(x,y) {
    if (x > y) {
        let tmp = x;
        x = y;
        y = tmp;
    }

    return y - x;
}

diff(3,7);      // 4
diff(7,5);      // 2
```

В этой функции `diff(..)` необходимо убедиться в том, что значение `y` больше либо равно x, чтобы при вычитании (`y x`) результат был неотрицательным. Если значение `x` изначально больше (т. е. результат будет отрицательным), `x` и `y` меняются местами с использованием переменной tmp, чтобы результат оставался положительным. 

В этом простом примере вроде бы неважно, находится ли `tmp` внутри блока `if` или же существует на уровне функции, — конечно, эта переменная не должна быть глобальной! Однако в соответствии с принципом наименьшего раскрытия переменная tmp должна иметь настолько глубокую *область видимости*, насколько это возможно. По этой причине мы назначаем `tmp` *блоковую область видимости* (при помощи `let`) в границах блока `if`

### Сокрытие в функциональной области видимости

К этому моменту вам должно быть понятно, почему так важно скрывать объявления переменных и функций на самом нижнем уровне (с наибольшим уровнем вложенности) из всех возможных. Но как это сделать? 

Вам уже знакомы ключевые слова `let` и `const`, используемые для объявления с *блоковой областью видимости*; мы еще вернемся к ним для более подробного рассмотрения. Но для начала — как насчет сокрытия объявлений `var` или `function` в *областях видимости*? Это легко можно сделать, упаковав объявление в область видимости function. 

Рассмотрим пример, в котором *область видимости* в границах функции может принести пользу.

Математическая операция «факториал» (записывается в виде 6!) вычисляет произведение всех целых чисел от заданного вниз до 1 — на самом деле можно остановиться на 2, потому что при умножении на 1 ничего не меняется. Иначе говоря, 6! — то же самое, что 6 * 5!, а это то же самое, что 6 * 5 * 4! и т. д. Из-за природы вычислений, если вы вычислили факториал некоторого числа (например, 4!), проделывать эту работу заново уже не нужно, так как ответ всегда будет одним и тем же. 

Итак, если вы вычисляете факториал 6, а потом вдруг потребуется вычислить факториал 7, это может привести к избыточному вычислению факториалов всех целых чисел от 2 до 6. Но если вы желаете потратить немного памяти ради повышения скорости, проблему избыточных вычислений можно решить кэшированием факториала каждого целого числа после его вычисления:

```js
var cache = {};

function factorial(x) {
    if (x < 2) return 1;
    if (!(x in cache)) {
        cache[x] = x * factorial(x - 1);
    }
    return cache[x];
}

factorial(6);
// 720

cache;
// {
//     "2": 2,
//     "3": 6,
//     "4": 24,
//     "5": 120,
//     "6": 720
// }

factorial(7);
// 5040
```

^0d8259

Все вычисленные факториалы сохраняются в кэше, так что между несколькими вызовами `factorial(..)` результаты предыдущих вычислений остаются. Однако переменная cache очевидно является приватной деталью работы factorial(..), а не чем-то таким, что должно раскрываться во внешней области видимости, особенно в *глобальной области видимости*.

>[!info] Примечание
>Здесь функция `factorial(..)` является рекурсивной (т. е. вызывающей саму себя), но это сделано только для компактности кода. С нерекурсивной реализацией анализ *областей видимости* в отношении кэширования был бы точно таким же.

Но проблема *чрезмерного раскрытия* не сводится к простому сокрытию переменной `cache` внутри `factorial(..)`, как могло бы показаться. Так как переменная `cache` должна пережить несколько вызовов, она должна находиться в области видимости за пределами этой функции. Что же делать? 

Нужно определить для `cache` другую *область видимости* (между *внешней/глобальной областью видимости* и *внутренней областью видимости* `factorial(..)` ): 

```js
// outer/global scope

function hideTheCache() {
    // "middle scope", where we hide `cache`
    var cache = {};

    return factorial;

    // **********************

    function factorial(x) {
        // inner scope
        if (x < 2) return 1;
        if (!(x in cache)) {
            cache[x] = x * factorial(x - 1);
        }
        return cache[x];
    }
}

var factorial = hideTheCache();

factorial(6);
// 720

factorial(7);
// 5040
```

Функция `hideTheCache()` не имеет другой цели, кроме создания для `cache` *области видимости*, чтобы значение сохранялось между вызовами factorial(..). Но чтобы функция `factorial(..)` имела доступ к `cache`, она должна определяться в той же области видимости. Затем ссылка на функцию возвращается в виде значения из `hideTheCache()` и сохраняется в переменной *внешней области видимости*, которая тоже называется `factorial`. Теперь при вызове `factorial(..)` (многократном) его долгосрочная переменная `cache` остается скрытой, но доступной только для `factorial(..)`. 

Хорошо, но… будет крайне утомительно определять (и присваивать имя) область видимости функции `hideTheCache(..)` каждый раз, когда возникнет необходимость в сокрытии переменной/функции, особенно если учесть, что мы захотим избежать конфликтов имен и будем присваивать каждому вхождению уникальное имя. 

>[!info] Примечание
>Такой прием — кэширование вычисляемого вывода функции для оптимизации быстродействия, если ожидаются повторные вызовы с теми же входными данными, — весьма распространен в функциональном программировании (*FP*), где он называется мемоизацией; этот способ кэширования основан на замыканиях (см. главу 7). Также следует учитывать потенциальные проблемы с затратами памяти (см. раздел «Несколько слов о памяти», приложение Б). Библиотеки *FP* обычно предоставляют оптимизированную и проверенную реализацию мемоизации функций, которые занимают место приведенной функции `hideTheCache(..)`. Мемоизация выходит за рамки нашего обсуждения. За дополнительной информацией обращайтесь к моей книге *[Functional-Light JavaScript](https://github.com/getify/Functional-Light-JS/tree/master)*.
>
>Ещё источник по [FP](https://github.com/MostlyAdequate/mostly-adequate-guide-ru)

Чтобы не определять новую функцию с уникальным именем каждый раз, когда возникнет одна из этих ситуаций «создание *области видимости* только для сокрытия переменной», возможно, лучше воспользоваться функциональным выражением:

```js
var factorial = (function hideTheCache() {
    var cache = {};

    function factorial(x) {
        if (x < 2) return 1;
        if (!(x in cache)) {
            cache[x] = x * factorial(x 1);
        }
        return cache[x];
    }

    return factorial;
})();

factorial(6);
// 720

factorial(7);
// 5040
```

Но постойте! В этом случае для сокрытия `cache` все равно используется функция для создания области видимости, и в этом случае функция все равно называется `hideTheCache`. И чего мы здесь добились? 

Вспомните из раздела [[3. Цепочка областей видимости#Область видимости имени функции|«Область видимости имени функции» (глава 3)]], что происходит с идентификатором имени из функционального выражения. Так как `hideTheCache(..)` определяется как функциональное выражение вместо объявления функции, ее имя находится в отдельной области видимости — по сути, в той же области видимости, что и `cache`, вместо внешней/глобальной области видимости. 

Это означает, что всем вхождениям этого функционального выражения можно присвоить одинаковые имена и никаких конфликтов не возникнет. Или, что более уместно, каждому вхождению можно присвоить семантическое имя на основании того, что мы собираемся скрыть, не беспокоясь о том, что выбранное имя может конфликтовать с любой другой областью видимости функционального выражения в программе.

Более того, имя возможно полностью опустить — в результате будет получено анонимное функциональное выражение. В приложении А обсуждается важность назначения имен даже для таких функций, создаваемых исключительно ради области видимости.

#### Немедленный вызов функциональных выражений

В приведенной рекурсивной программе вычисления факториала есть еще один аспект, который легко упустить: строка в конце функционального выражения с символами `})()`;. 

Обратите внимание: все функциональное выражение заключено в круглые скобки `(..)`, а затем в конце добавляется вторая пара круглых скобок `()`; она вызывает только что определенное функциональное выражение. Более того, в данном случае первая пара окружающих скобок `(..)` вокруг функционального выражения не является строго необходимой (подробнее об этом чуть позже), но мы используем их ради удобочитаемости. 

Итак, мы определяем функциональное выражение, которое немедленно вызывается в программе. У этого распространенного паттерна есть (весьма неожиданное) имя: немедленно вызываемое функциональное выражение, или `IIFE` (*Immediately Invoked Function Expression*). 

`IIFE` полезны в тех ситуациях, когда вы хотите создать область видимости для сокрытия переменных/функций. Так как это выражение, оно может использоваться в любой точке программы `JS`, в которой допустимо выражение. `IIFE` могут назначаться имена, как в случае с `hideTheCache(),` или (что бывает намного чаще) они могут оставаться анонимными. Также они могут быть автономными или частью другой команды — `hideTheCache()` возвращает ссылку на функцию `factorial()`, которая затем присваивается переменной `factorial`. 

Для сравнения приведу пример автономной `IIFE`

```js
// outer scope

(function(){
    // inner hidden scope
})();

// more outer scope
```


>[!info] Примечание
>Технически окружающие скобки `(..)` — не единственный синтаксический способ, гарантирующий, что функция в `IIFE` будет рассматриваться парсером `JS` как функциональное выражение. Другие возможности рассматриваются в приложении А. 

#### Границы функций

Учтите, что использование `IIFE` для определения *области видимости* может иметь непредсказуемые последствия в зависимости от окружающего кода. Так как `IIFE` является полной функцией, границы функции изменяют поведение некоторых команд/конструкций. 

Например, команда `return`, заключенная в `IIFE`, может изменить свой смысл, потому что после этого `return` будет относиться к функции `IIFE`. `IIFE` с нестрелочными функциями также изменяют привязку ключевого слова `this` — об этом подробнее в книге «Объекты и классы». И такие команды, как `break` и `continue`, не будут работать через границу функции `IIFE` для управления внешним циклом или блоком. 

Таким образом, если код, который нужно заключить в область видимости, содержит `return`, `this`, `break` или `continue`, `IIFE` вряд ли будет лучшим выходом. В этом случае можно рассмотреть возможность создания области видимости с блоком вместо функции. 

### Создание областей видимости с блоками 

Вероятно, к этому моменту вы уже достаточно уверенно чувствуете себя с созданием областей видимости для ограничения раскрытия идентификаторов. До сих пор мы делали это с использованием *области видимости функции* (например, `IIFE`). Но рассмотрим использование объявления `let` с вложенными блоками. В общем случае любая пара фигурных скобок `{ .. }`, являющаяся командой, будет действовать как блок, но не обязательно как *область видимости*. 

Блок становится *областью видимости* только в случае необходимости для размещения объявлений с *блоковой областью видимости* (т. е. `let` или `const`). Пример: 

```js
{
    // not necessarily a scope (yet)

    // ..

    // now we know the block needs to be a scope
    let thisIsNowAScope = true;

    for (let i = 0; i < 5; i++) {
        // this is also a scope, activated each
        // iteration
        if (i % 2 == 0) {
            // this is just a block, not a scope
            console.log(i);
        }
    }
}
// 0 2 4
```

Не все пары фигурных скобок `{ .. }` создают блоки (а следовательно, становятся кандидатами для превращения в области видимости): 
- объектные литералы используют пары фигурных скобок `{ .. }`для ограничения своих списков «*ключ — значение*», но такие объектные значения не являются областями видимости;
- `class` использует фигурные скобки `{ .. }` для определения тела, но блок или область видимости при этом не определяется;
- тело функции заключается в `{ .. }`, но с технической точки зрения это блоком не является — это одна команда для тела функции. Тем не менее это (функциональная) область видимости;
- пара фигурных скобок `{ .. }` в команде `switch` (в которую заключается набор условий `case`) не определяет *блок/область видимости*. 

Кроме этих «неблоковых» примеров пара фигурных скобок `{ .. }` может определить блок, присоединенный к команде (как `if` или `for`), или автономный (как внешняя пара фигурных скобок `{ .. }` в приведенном фрагменте). Явный блок такого типа — если он не содержит объявлений, то не является областью видимости, — не имеет практической цели, хотя и может послужить полезным семантическим сигналом. 

Явные автономные блоки `{ .. }` всегда были допустимым элементом синтаксиса `JS`, но так как до включения `let`/`const` в `ES6` они не могли создавать область видимости, то использовались достаточно редко. После появления `ES6` они начинают немного наверстывать упущенное.

В большинстве языков, поддерживающих блоковую область видимости, явная блоковая область видимости стала крайне распространенным паттерном для создания узких сегментов видимости для одной или нескольких переменных. Таким образом, в соответствии с принципом наименьшего раскрытия этот паттерн также должен найти более широкое применение и в `JS`; используйте (явные) блоковые области видимости для сужения раскрытия идентификаторов до минимального практического уровня. 

Явная блоковая область видимости может принести пользу даже внутри другого блока (независимо от того, является внешний блок областью видимости или нет).
Пример:

```js
if (somethingHappened) {
    // this is a block, but not a scope

    {
        // this is both a block and an
        // explicit scope
        let msg = somethingHappened.message();
        notifyOthers(msg);
    }

    // ..

    recoverFromSomething();
}
```

Здесь пара фигурных скобок `{ .. }` в команде `if` создает еще меньшую внутреннюю блоковую область видимости для `msg`, так как эта переменная не нужна для всего блока if. Многие разработчики просто ограничили бы видимость `msg` блоком `if` и двинулись бы дальше. И откровенно говоря, если вам приходится просматривать всего несколько строк кода, такое решение вполне можно назвать делом вкуса. Но с ростом кодовой базы проблемы с чрезмерным раскрытием становятся более заметными.

Так ли это важно, чтобы добавлять лишнюю пару скобок { .. } и уровень отступа? Я считаю, что вам стоит следовать принципу наименьшего раскрытия и всегда (в пределах разумного) определять наименьший блок для каждой переменной. Соответственно, я рекомендую использовать дополнительную явную блоковую область видимости, как показано ранее. 

Вспомните обсуждение ошибок `TDZ` из раздела [[5. (Не такой уж) тайный жизненный цикл переменных#Неинициализированные переменные (TDZ)|«Неинициализированные переменные (TDZ) (глава 5)]]. Тогда я рекомендовал для минимизации риска ошибок `TDZ` с объявлениями `let`/`const` всегда размещать эти объявления в начале области видимости.

Если вдруг в какой-то момент вы разместите объявление `let` в середине *области видимости*, прежде всего подумайте: «О нет! Опасно — ошибки `TDZ`!» Если это объявление `let` не задействовано в первой половине блока, используйте явную внутреннюю блоковую область видимости, чтобы дополнительно сузить его раскрытие.

Другой пример с явной блоковой областью видимости: 

```js
function getNextMonthStart(dateStr) {
    var nextMonth, year;

    {
        let curMonth;
        [ , year, curMonth ] = dateStr.match(
                /(\d{4})-(\d{2})-\d{2}/
            ) || [];
        nextMonth = (Number(curMonth) % 12) + 1;
    }

    if (nextMonth == 1) {
        year++;
    }

    return `${ year }-${
            String(nextMonth).padStart(2,"0")
        }-01`;
}
getNextMonthStart("2019-12-25");   // 2020-01-01
```

Для начала определим области видимости и их идентификаторы: 
1. Внешняя/глобальная область видимости содержит один идентификатор — функцию `getNextMonthStart(..)`. 
2. Область видимости функции `getNextMonthStart(..)` содержит три идентификатора: `dateStr` (параметр), `nextMonth` и `year`.
3. Пара фигурных скобок `{ .. }` определяет внутреннюю блоковую область видимости, которая включает одну переменную: `curMonth`. 

Почему же тогда `curMonth` размещается в явной блоковой области видимости, а не рядом с `nextMonth` и `year` в области видимости функции верхнего уровня? Потому что переменная `curMonth` нужна только для первых двух команд; на уровне области видимости функции она чрезмерно раскрыта.

В этом маленьком примере риски от чрезмерного раскрытия `curMonth` сильно ограничены. Однако преимущества принципа наименьшего раскрытия лучше всего реализуются тогда, когда вы обзаводитесь привычкой минимизировать раскрытие `области видимости` по умолчанию. Если вы будете последовательно следовать этому принципу даже в маломасштабных ситуациях, это только принесет пользу с ростом вашей программы. 

Теперь рассмотрим более содержательный пример: 

```js
function sortNamesByLength(names) {
    var buckets = [];

    for (let firstName of names) {
        if (buckets[firstName.length] == null) {
            buckets[firstName.length] = [];
        }
        buckets[firstName.length].push(firstName);
    }

    // a block to narrow the scope
    {
        let sortedNames = [];

        for (let bucket of buckets) {
            if (bucket) {
                // sort each bucket alphanumerically
                bucket.sort();

                // append the sorted names to our
                // running list
                sortedNames = [
                    ...sortedNames,
                    ...bucket
                ];
            }
        }

        return sortedNames;
    }
}

sortNamesByLength([
    "Sally",
    "Suzy",
    "Frank",
    "John",
    "Jennifer",
    "Scott"
]);
// [ "John", "Suzy", "Frank", "Sally",
//   "Scott", "Jennifer" ]
```

Здесь 6 идентификаторов объявляются в 5 разных *областях видимости*. Могли бы все эти переменные существовать в одной внешней/глобальной области видимости? Технически да, потому что они имеют уникальные имена, что исключает возможные конфликты имен. Но такая организация кода была бы крайне примитивной и с большой вероятностью привела бы как к недоразумениям, так и к будущим ошибкам. 

Мы выделяем каждую из этих переменных во внутреннюю вложенную *область видимости*. Каждая переменная определяется в области видимости с наибольшим уровнем вложенности, чтобы программа работала так, как требуется. 

Переменную `sortedNames` можно было бы определить в *области видимости* функции верхнего уровня, но она используется только во второй половине функции. Чтобы избежать чрезмерного раскрытия этой переменной в области видимости более высокого уровня, мы снова следуем принципу наименьшего раскрытия и оформляем ее с блоковой видимостью во внутренней явной *блоковой области видимости*. 

#### var и let

Теперь поговорим об объявлении `var buckets`. Эта переменная используется во всей функции (кроме последней команды `return`). Любая переменная, которая должна быть доступна во всем коде функции (или почти во всем), должна объявляться так, чтобы область ее использования была очевидной.

>[!info] Примечание
>Параметр `names` не используется во всей функции, но ограничить область видимости параметра невозможно, поэтому он ведет себя как объявление с областью видимости функции. 

Почему же мы используем `var` вместо `let` для объявления переменной `buckets`? Для выбора `var` есть как семантические, так и технические причины. 

С точки зрения стилистики объявление `var` всегда, с первых дней `JS`, означало переменную, принадлежащую всей функции. Как было указано в разделе [[1. Что такое область видимости#Лексические области видимости|«Лексическая видимость» (глава 1)]], `var` присоединяется к ближайшей вмещающей области видимости функции, где бы она ни находилась. Это справедливо даже в том случае, если `var` размещается внутри блока: 

```js
function diff(x,y) {
    if (x > y) {
        var tmp = x;    // `tmp` is function-scoped
        x = y;
        y = tmp;
    }

    return y x;
}
```

Даже при том что объявление `var` располагается внутри блока, его область видимости определяется функцией (`diff(..))`, а не блоком. 

И хотя объявление `var `может располагаться в блоке (и при этом все равно будет иметь функциональную область видимости), я не рекомендую использовать этот прием, кроме особых случаев (рассмотренных в приложении А). В остальных случаях использование `var` следует ограничивать областью верхнего уровня функции.

Почему бы не использовать `let` в этой же точке? Потому что `var` визуально отличается от `let` и потому четко сигнализирует: эта переменная имеет функциональную область видимости. Использование `let` в области видимости верхнего уровня, особенно если оно не находится в нескольких начальных строках функции и когда все остальные объявления в блоках используют `let`, не привлекает внимания к отличиям от объявлений с функциональной *областью видимости*. 

Иначе говоря, я считаю, что `var` лучше передает функциональную область видимости, чем `let`, а `let` одновременно передает (и реализует) блоковую область видимости там, где недостаточно `var`. Пока вашим программам понадобятся переменные как с функциональной, так и с блоковой *областью видимости*, самое разумное и удобочитаемое решение — использовать как объявления `var`, так и `let`, каждое для наиболее подходящей цели. 

Существуют и другие семантические и практические причины для выбора `var` или `let` в разных ситуациях. Ситуации, в которых уместно применение `var` и `let`, более подробно рассматриваются в приложении А.

>[!info] Примечание
>Моя рекомендация использовать как `var`, так и `let` очевидным образом спорна и противоречит мнению большинства. Гораздо чаще встречаются утверждения вида: «Объявления `var` сломаны, `let` их чинит» или: «Никогда не используйте `var`, `let` — идеальная замена». Эти мнения имеют право на существование, но это всего лишь мнения, как и мое. Объявления `var` не сломаны и не устарели; они работали с первых дней существования `JS` и будут работать, пока существует `JS`

#### Где использовать let? 

Мой совет ограничить использование `let` (почти всегда) только функциональной областью видимости верхнего уровня означает, что в большинстве других объявлений должно использоваться ключевое слово `let`. Но возможно, вас все еще интересует, как решить, какой тип выбрать для каждого объявления в вашей программе?

Принцип наименьшего раскрытия уже направляет такие решения, но давайте выразим критерий выбора явно. Выбор не зависит от того, какое ключевое слово положено использовать в конкретной ситуации. Чтобы принять решение, спросите себя, какое минимальное раскрытие области видимости будет достаточным для этой переменной. 

Ответив на этот вопрос, вы будете знать, к какой *области видимости* должна принадлежать переменная — блоковой или функциональной. Если вы изначально решили, что переменная должна иметь блоковую область видимости, а позднее осознаете, что ее следует поднять до функциональной *области видимости*, это повлияет не только на местоположение объявления этой переменной, но и на используемое при объявлении ключевое слово. Процесс принятия решений должен проходить именно так. 

Если объявление принадлежит блоковой области видимости, используйте `let`. Если оно принадлежит функциональной области видимости, используйте `var` (еще раз: это только мое мнение). Чтобы понять суть этого решения, можно подумать, как бы выглядела версия этой программы до ES6. Например, вспомним приведенную выше функцию `diff(..)`:

```js
function diff(x,y) {
    var tmp;

    if (x > y) {
        tmp = x;
        x = y;
        y = tmp;
    }

    return y x;
}
```

В этой версии `diff(..)` переменная `tmp` очевидно объявляется в `функциональной области видимости`. Подходит ли это для `tmp`? На мой взгляд, нет. Переменная `tmp` нужна только для этих нескольких команд. Для команды return она не нужна, поэтому должна иметь *блоковую область видимости*. 

До выхода ES6 ключевого слова `let` не было, поэтому придать ему блоковую область видимости было невозможно. Но для передачи ваших намерений можно было использовать доступные средства: 

```js
function diff(x,y) {
    if (x > y) {
// `tmp` по-прежнему имеет функциональную область
// видимости,но ее размещение здесь является
// семантическим сигналом о блоковой области видимости
        var tmp = x;
        x = y;
        y = tmp;
    }

    return y x;
}
```

Объявление `var` для переменной `tmp` внутри команды `if` сигнализирует читателю кода, что `tmp` принадлежит этому блоку. Несмотря на то что `JS` не ограничивает область видимости, семантический сигнал все равно принесет некоторую пользу для читателя вашего кода. 

Следуя этому принципу, вы можете найти все объявления `var`, расположенные внутри подобных блоков, и переключить их на `let` для передачи семантического сигнала. На мой взгляд, это правильный способ использования `let`. 

В другом примере исторически использовалось объявление `var`, но теперь практически всегда в цикле `for` должно использоваться `let`: 

```js
for (var i = 0; i < 5; i++) {
    // do something
}
```

Где бы ни определялся такой цикл, переменная `i`, по сути, всегда используется только внутри цикла; в этом случае принцип наименьшего раскрытия требует, чтобы она объявлялась с ключевым словом `let` вместо `var`: 

```js
for (let i = 0; i < 5; i++) {
    // do something
}
```

Подобное переключение с `var` на `let` нарушит работоспособность вашего кода только в одном случае: если он зависит от обращения к переменной цикла (`i`) за пределами/после цикла:

```js
for (var i = 0; i < 5; i++) {
    if (checkValue(i)) {
        break;
    }
}

if (i < 5) {
    console.log("The loop stopped early!");
}
```

Этот паттерн встречается не так уж редко, но по мнению большинства разработчиков, он отдает плохо структурированным кодом. В подобных случаях рекомендуется использовать для этой цели другую переменную с *внешней областью видимости*: 

```js
var lastI;

for (let i = 0; i < 5; i++) {
    lastI = i;
    if (checkValue(i)) {
        break;
    }
}

if (lastI < 5) {
    console.log("The loop stopped early!");
}
```

Переменная `lastI` нужна во всей области видимости, поэтому она объявляется с ключевым словом `var`. Переменная `i` нужна только в (каждой) итерации цикла, поэтому она объявляется с ключевым словом `let`. 

#### В чем загвоздка? *(What's the Catch? а что насчёт catch?)*

До настоящего момента утверждалось, что `var` и параметры имеют функциональную область видимости, а `let`/`const` сигнализируют об объявлениях с блоковой областью видимости. Существует только одно маленькое исключение, заслуживающее упоминания: секция `catch`.

С момента появления `try..catch` в `ES3` (в 1999 году) в секции `catch` использовалась дополнительная (малоизвестная) возможность объявления блоковой области видимости:

```js
try {
    doesntExist();
}
catch (err) {
    console.log(err);
    // ReferenceError: 'doesntExist' is not defined
    // ^^^^ message printed from the caught exception

    let onlyHere = true;
    var outerVariable = true;
}

console.log(outerVariable);     // true

console.log(err);
// ReferenceError: 'err' is not defined
// ^^^^ this is another thrown (uncaught) exception
```

Переменная `err`, объявленная в секции `catch`, имеет блоковую область видимости для данного блока. Блок секции `catch` может содержать другие объявления с блоковой областью видимости, создаваемые `let`. Однако объявление `var` внутри этого блока все еще присоединяется к *внешней функциональной/глобальной области видимости*.

В *ES2019* (недавно, на момент написания книги) секции `catch` были изменены и их объявление стало необязательным; если объявление опущено, то блок `catch` (по умолчанию) уже не является областью видимости, но при этом он остается блоком! 

Таким образом, если нужно отреагировать на факт возникновения исключения (после чего можно корректно продолжить работу), но само значение ошибки вас не интересует, объявление `catch` можно опустить:

```js
try {
    doOptionOne();
}
catch {   // catch-declaration omitted
    doOptionTwoInstead();
}
```

Это небольшое, но приятное упрощение синтаксиса для довольно распространенного случая использования; оно также может быть чуть более эффективным для удаления избыточных областей видимости! 

### Объявления функций в блоках (FiB)

Итак, вы видели, что объявления с `let` или `const` имеют блоковую область видимости, а объявления `var` — функциональную. А как насчет объявлений, размещаемых непосредственно внутри блоков? Эта возможность называется `FiB` (*Functions in Blocks*). 

Обычно мы рассматриваем объявления функций как эквиваленты объявлений `var`. Так значит, они имеют функциональную область видимости, как и `var`?

Нет и да. Знаю, это звучит странно. Разберем подробнее: 

```js
if (false) {
    function ask() {
        console.log("Does this run?");
    }
}
ask();
```

Как вы думаете, что сделает эта программа? Три возможных варианта: 

1. При вызове `ask()` может произойти исключение `ReferenceError`, потому что идентификатор `ask` имеет блоковую область видимости для блока `if`, а следовательно, недоступен *во внешней/ глобальной области видимости*. 
2. При вызове `ask()` может произойти исключение `TypeError`, потому что идентификатор `ask` существует, но он содержит `undefined` (потому что команда `if` не выполняется), а следовательно, не является вызываемой функцией. 
3. Вызов `ask()` выполняется правильно и выводит сообщение `Does it run`?

А теперь самая загадочная часть: в зависимости от того, в какой среде `JS` будет выполняться этот фрагмент кода, вы можете получить разные результаты! Это одна из немногих странных областей, в которых существующее унаследованное поведение противоречит предсказуемости результата. 

Спецификация `JS` гласит, что объявления функций внутри блоков имеют блоковую область видимости, поэтому ответом должен быть пункт (1). Однако большинство браузерных ядер `JS` (включая движок `v8`, который происходит от `Chrome`, но также используется в `Node`) ведет себя в соответствии с пунктом (2); это означает, что идентификатор имеет область видимости вне блока `if`, но значение-функция не инициализируется автоматически, поэтому оно остается равным `undefined`. 

Почему браузерным движкам `JS` разрешается нарушать своим поведением спецификацию? Потому что эти движки уже обладали поведением, связанным с `FiB`, до появления блоковой видимости в ES6, и существовали опасения, что изменения, направленные на соответствие спецификации, могут нарушить работоспособность существующего кода `JS` веб-сайтов. Из-за этого в приложении B спецификации `JS` было сделано исключение, позволяющее некоторые отклонения для браузерных движков `JS` (и только!). 

>[!info] Примечание
>Обычно `Node` не относится к браузерным средам `JS`, так как обычно работает на сервере. Однако движок `Node v8` является общим с браузером Chrome (и Edge). Так как движок `v8` сначала был браузерным движком `JS`, он включает исключение из приложения B, а это означает, что браузерные исключения распространяются на `Node`. 

Одним из самых распространенных сценариев использования для размещения объявления функции в блоке является условное определение функции тем или иным способом (например, в команде `if..else`) в зависимости от некоторого состояния среды. Пример: 

```js
if (typeof Array.isArray != "undefined") {
    function isArray(a) {
        return Array.isArray(a);
    }
}
else {
    function isArray(a) {
        return Object.prototype.toString.call(a)
            == "[object Array]";
    }
}
```

Такое структурирование кода по соображениям эффективности выглядит соблазнительно, так как проверка `typeof Array.isArray` выполняется только один раз, в отличие от определения всего одной версии `isArray(..)` и размещения команды `if` внутри нее — в этом случае каждый вызов будет сопровождаться избыточной проверкой. 

>[!info] Примечание
>Кроме рисков, связанных с расхождениями `FiB`, у условного определения функций есть и другая проблема: оно усложняет отладку таких программ. Если вы столкнетесь с ошибкой в функции `isArray(..)`, вам придется сначала вычислить, какая именно реализация `isArray(..)` при этом выполнялась! А иногда ошибка может возникнуть из-за того, что была выбрана неправильная реализация из-за ошибки в условии! Если вы определили несколько версий функции, такую программу всегда труднее понять и она всегда создает больше проблем с сопровождением.

В дополнение к предыдущим фрагментам, с `FiB` также связан ряд других граничных случаев; скорее всего, такое поведение в разных браузерных и небраузерных средах `JS` (движках `JS`, которые не базируются на браузерах) будет с большой вероятностью изменяться. Пример: 

```js
if (true) {
    function ask() {
        console.log("Am I called?");
    }
}

if (true) {
    function ask() {
        console.log("Or what about me?");
    }
}

for (let i = 0; i < 5; i++) {
    function ask() {
        console.log("Or is it one of these?");
    }
}

ask();

function ask() {
    console.log("Wait, maybe, it's this one?");
}
```

Напомню, что поднятие функции в соответствии с описанием  [[5. (Не такой уж) тайный жизненный цикл переменных#Когда можно использовать переменную?|«Когда можно использовать переменную?»( глава 5)]] может навести на мысль, что последний вызов ask() из этого фрагмента с сообщением `Wait, maybe...` поднимется над вызовом `ask()`. Так как это последнее объявление функции с таким именем, оно должно «победить», верно? К сожалению, нет.

Не буду даже пытаться документировать все странные граничные случаи или пытаться объяснить, почему каждый из них ведет себя именно так, а не иначе. На мой взгляд, такая информация нужна только для знатоков экзотических нюансов унаследованного поведения. 

Когда я говорю о `FiB`, меня интересует другое: какой совет я могу дать, чтобы обеспечить предсказуемую работу вашего кода во всех обстоятельствах? 

На мой взгляд, единственный практичный способ избежать капризов `FiB` — просто полностью избегать `FiB`. Другими словами, никогда не размещайте объявления функций непосредственно внутри любого блока. Всегда размещайте объявления функций в любой точке области верхнего уровня функции (или глобальной области видимости). 

Таким образом, в более раннем примере `if..else` я бы порекомендовал избегать условного определения функций, если это возможно. Да, может быть, такое решение будет чуть менее производительным, но в целом это лучшее решение: 

```js
function isArray(a) {
    if (typeof Array.isArray != "undefined") {
        return Array.isArray(a);
    }
    else {
        return Object.prototype.toString.call(a)
            == "[object Array]";
    }
}
```

Если снижение быстродействия создает критические проблемы для вашего приложения, то рекомендую рассмотреть следующий подход: 

```js
var isArray = function isArray(a) {
    return Array.isArray(a);
};

// override the definition, if you must
if (typeof Array.isArray == "undefined") {
    isArray = function isArray(a) {
        return Object.prototype.toString.call(a)
            == "[object Array]";
    };
}
```

Важно заметить, что здесь в команде `if` размещается функциональное выражение, а не объявление. Размещение функциональных выражений в блоках — абсолютно нормальное и допустимое решение. В нашем обсуждении `FiB` речь идет о нежелательности функциональных объявлений в блоках. 

Даже если вы протестировали свою программу и она работает правильно, мелкие преимущества от использования `FiB` в вашем коде намного меньше будущих потенциальных рисков путаницы от других разработчиков или отклонений при выполнении вашего кода в других средах `JS`. 

`FiB` не стоит того, и от этой возможности стоит держаться подальше. 

### Напоследок о блоках

Правила лексических областей видимости в языках программирования существуют для того, чтобы правильно организовать переменные в вашей программе — как для практических целей, так и для передачи семантических сигналов о коде. 

И один из самых важных организационных приемов — предотвращение раскрытия переменных в нежелательных областях видимости (принцип наименьшего раскрытия). Хочется верить, что вы теперь понимаете *блоковую область видимости* намного лучше, чем прежде. 

Надеюсь, вы чувствуете, что ваша основа для понимания лексической видимости заметно укрепилась. И с этой прочной основы можно перейти к непростой теме следующей главы — [[7. Использование замыканий|замыканиям]].

[^1]: **Принцип наименьших привилегий**, также известный как **принцип минимальных привилегий** ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") Principle of least privilege) или просто **минимальные привилегии**, в [информационной безопасности](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C "Информационная безопасность"), [информатике](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0 "Информатика") и других областях — принцип организации доступа к ресурсам, когда в тот или иной уровень абстракции от вычислительной среды, каждый модуль (такой, как [процесс](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81_\(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0\) "Процесс (информатика)"), [пользователь](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C "Пользователь") или [программа](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0 "Компьютерная программа"), которые мы рассматриваем) должны иметь доступ к такой информации и ресурсам, которые минимально необходимы для успешного выполнения его рабочей цели
Это означает давать пользователю только те привилегии, которые являются абсолютно необходимыми для того, чтобы сделать свою работу. Например, учётной записи пользователя, который занимается резервным копированием, не нужно устанавливать другое программное обеспечение, кроме того, что ему необходимо для работы. Любые другие привилегии, например как установка [программного обеспечения](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B5_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5 "Программное обеспечение") и так далее должны быть заблокированы. Принцип распространяется также на пользователей [персонального компьютера](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80 "Персональный компьютер") дома, где они должны работать в учётной записи обычного пользователя и открывать свою учётную запись [администратора](https://ru.wikipedia.org/wiki/%D0%90%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B0%D1%82%D0%BE%D1%80 "Администратор") (защищённую [паролем](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%BE%D0%BB%D1%8C "Пароль")) только тогда, когда ситуация требует этого.

Применительно к пользователям, **принцип наименьшего допуска**, означает предоставление пользователям только минимально необходимых возможностей при работе с [операционной системой](https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0 "Операционная система") и приложениями.
[*Ссылка на источник*](https://ru.wikipedia.org/wiki/Принцип_минимальных_привилегий)

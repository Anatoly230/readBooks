### Введение

Пока что мы подробно изучали все тонкости лексических *областей видимости* и их влияния на организацию и использование переменных в наших программах. 

Сейчас мы вернемся на более общий уровень абстракции и переключимся на традиционно пугающую тему *замыканий*. Не бойтесь! Разобраться в ней можно и без докторской степени в области компьютерной теории. Наша общая цель в этой книге — не просто разобраться в *областях видимости*, а более эффективно использовать их в структуре программ; без *замыканий* сделать это не получится.

Вспомните главный вывод из [[6. Ограничение раскрытия областей видимости|главы 6]] : принцип наименьшего раскрытия (POLE) рекомендует использовать блоковые (и *функциональные*) *области видимости* для ограничения раскрытия переменных в *областях видимости*. Соблюдение этого принципа делает ваш код более понятным и простым в сопровождении и помогает избежать многих потенциальных ловушек (конфликтов имен и т. д.). 

Замыкания в каком-то смысле расширяют этот принцип: если переменные понадобятся позже, то вместо того чтобы размещать их в больших внешних областях видимости, мы можем *инкапсулировать* их (сузить их *область видимости*), но при этом сохранить их *доступность* из функций, чтобы расширить возможности их использования. Функции сохраняют информацию об этих переменных с ограниченной областью видимости в замыканиях.

Пример замыканий уже встречался в предыдущей главе (`factorial(..)` [[6. Ограничение раскрытия областей видимости#^0d8259|в главе 6]] ), и вы почти наверняка пользовались ими в своих программах. Если вам когда-либо доводилось писать функцию обратного вызова, которая обращалась к переменным за пределами своей области видимости… да, представьте — это было *замыкание*.

*Замыкание* — одна из самых важных характеристик языка, изобретенных в программировании. *Замыкания* лежат в основе многих фундаментальных парадигм программирования, включая функциональное программирование (`FP`), модули и даже в какой-то степени объектно-ориентированное проектирование. Хорошо владеть  и эффективно применять многие важные паттерны проектирования без понимания *замыканий* не выйдет. 

Для рассмотрения всех аспектов *замыканий* в этой главе пришлось дать много продолжительных объяснений и примеров кода. Не торопитесь и убедитесь в том, что вы полностью поняли каждую часть, прежде чем переходить к следующей.
### Как увидеть замыкание 

Изначально *замыкание* было математической концепцией из области *лямбда-исчисления*. Но я не собираюсь сыпать математическими формулами или использовать заумные термины и обозначения для его определения. 

Вместо этого я намерен сосредоточиться на практической точке зрения. Мы начнем с определения замыканий в контексте того, что можно наблюдать в различных аспектах поведения наших программ, в отличие от того, что происходило бы, если бы замыкания в `JS` не поддерживались. Но позднее в этой главе мы рассмотрим *замыкания* с другой точки зрения. 

*Замыкание* является аспектом поведения *функций* и только *функций*. Если вы работаете не с *функцией*, то *замыкание* не действует. *Объект не может иметь замыкания*, *класс не может иметь замыкания* (хотя его отдельные функции/методы — могут). Короче, замыкания присущи только функциям. 

Чтобы *замыкание* проявилось, *функция* должна быть вызвана, причем вызвана не в той ветви *цепочки областей видимости*, в которой она была определена. Функция, выполняемая в той же области видимости, в которой она была определена, будет работать одинаково независимо от того, возможны замыкания или нет; с позиций наблюдаемости и определения это *замыканием* не является. 

Рассмотрим пример кода с помеченными цветными областями видимости (из [[2. Лексическая видимость#^442c41|главы 2]]):

```js
// outer/global scope: RED(1)

function lookupStudent(studentID) {
    // function scope: BLUE(2)
	studentID=6
    var students = [
        { id: 14, name: "Kyle" },
        { id: 73, name: "Suzy" },
        { id: 112, name: "Frank" },
        { id: 6, name: "Sarah" }
    ];

    return function greetStudent(greeting){
        // function scope: GREEN(3)

        var student = students.find(
            student => student.id == studentID
        );

        return `${ greeting }, ${ student.name }!`;
    };
}

var chosenStudents = [
    lookupStudent(6),
    lookupStudent(112)
];

// accessing the function's name:
chosenStudents[0].name;
// greetStudent

chosenStudents[0]("Hello");
// Hello, Sarah!

chosenStudents[1]("Howdy");
// Howdy, Frank!
```

Первое, что следует заметить в этом коде, — что внешняя функция `lookupStudent(..)` создает и возвращает внутреннюю функцию с именем `greetStudent(..)`.` lookupStudent(..)` вызывается дважды, создавая два разных экземпляра своей внутренней функции `greetStudent(..)`; оба экземпляра сохраняются в массиве `chosenStudents`.
Чтобы убедиться в этом, мы проверяем свойство `.name` возвращенной функции, хранящейся в `chosenStudents[0]`, и это в самом деле оказывается экземпляром внутренней функции `greetStudent(..)`. 

После завершения каждого вызова ``lookupStudent(..)`` кажется, что все внутренние переменные пропадают, а их память освобождается в ходе сборки мусора (`GC`). Внутренняя функция — единственное, что возвращается и сохраняется. Но здесь-то в поведении возникают различия, которые мы можем наблюдать. 

Хотя функция `greetStudent(..)` получает один аргумент в параметре с именем `greeting`, она также обращается к `students` и `studentID` — идентификаторам, происходящим из окружающей области видимости `lookupStudent(..)`. Каждая из ссылок из внутренней функции на переменную во внешней *области видимости* называется замыканием. В научной терминологии каждый экземпляр` greetStudent(..)` замыкается по внешним переменным `students` и `studentID`. Что же делают `замыкания` в конкретном, наблюдаемом смысле?

Замыкание позволяет `greetStudent(..)` продолжать обращаться к этим внешним переменным даже после завершения внешней области видимости (после завершения каждого вызова `lookupStudent(..)`). Вместо того чтобы уничтожаться в ходе сборки мусора, экземпляры `students` и `studentID` будут оставаться в памяти. И позднее, при вызове экземпляра `greetStudent(..)`, эти переменные все еще будут доступны с сохранением своих текущих значений. 

Если бы функции  не имели *замыканий*, то завершение каждого вызова `lookupStudent(..)` немедленно уничтожало бы свою область видимости, а переменные `students` и `studentID` уничтожались бы в ходе сборки мусора. Что произойдет, когда позднее мы вызываем одну из функций `greetStudent(..)`? 

Если функция `greetStudent(..)` попытается обратиться к тому, что, по ее мнению, является переменной из области видимости СИНИЙ (2), но эта переменная не существует (к настоящему моменту), разумно предположить, что мы получим ошибку `Reference Error`, верно? 

Однако ошибки не будет. Тот факт, что выполнение `chosenStudents[0]("Hello")` работает и возвращает сообщение `Hello, Sarah!`, означает, что функция все еще может обращаться к переменным `students` и `studentID` — непосредственно наблюдаемый эффект замыкания!

#### Замыкание и стрелки

В действительности в предыдущем обсуждении была упущена маленькая подробность, которую, вероятно, упустили многие читатели!

Из-за того, насколько компактен синтаксис стрелочных функций `=>`, легко забыть, что они тоже создают область видимости (см. раздел [[3. Цепочка областей видимости#Стрелочные функции|«Стрелочные функции», глава 3)]]. Стрелочная функция `student => student.id == studentID` создает *еще одну область видимости* внутри *области видимости функции* `greetStudent(..)`. 

Развивая метафору цветных банок и камешков из [[2. Лексическая видимость#^baad76|главы 2]], если бы мы построили цветную диаграмму для этого кода, на ней появилась бы четвертая область видимости на уровне с максимальной вложенностью, поэтому понадобился бы четвертый цвет; например, для этой цели можно выбрать для этой области видимости обозначение ОРАНЖЕВЫЙ(4): 

```js
var student = students.find(
    student =>
        // function scope: ORANGE(4)
        student.id == studentID
);
```

Ссылка studentID в СИНИЙ (2) в действительности находится внутри *области видимости* ОРАНЖЕВЫЙ (4) вместо *области видимости* ЗЕЛЕНЫЙ (3) функции `greetStudent(..)`; кроме того, параметр `student` *стрелочной функции* относится к области видимости ОРАНЖЕВЫЙ (4), замещая student из ЗЕЛЕНЫЙ (3).

Как следствие, стрелочная функция, передаваемая в качестве обратного вызова методу `find(..)` массива, должна содержать замыкание по `studentID`, а не по функции `greetStudent(..)`, содержащей это замыкание. Особых проблем это не создает; все работает, как и ожидалось. Очень важно помнить о том, что даже крошечные стрелочные функции могут участвовать в системе замыканий. 

### Накопление замыканий
# здесь
Рассмотрим один из канонических примеров, часто приводимых для замыканий: 

```js
function adder(num1) {
    return function addTo(num2){
        return num1 + num2;
    };
}

var add10To = adder(10);
var add42To = adder(42);

add10To(15);    // 25
add42To(9);     // 51
```

Каждый экземпляр внутренней функции addTo(..) замыкается по своей собственной переменной num1 (со значениями 10 и 42 соответственно), так что num1 не исчезает из-за завершения adder(..). Когда позднее мы вызываем один из этих внутренних экземпляров addTo(..) (например, add10To(15)), переменная num1 из его замыкания продолжает существовать и все еще содержит исходное значение 10. Таким образом, операция может выполнить сложение 10 + 15 и возвращает ответ 25.

В предыдущем абзаце можно легко упустить одну важную подробность, поэтому я хочу снова подчеркнуть ее: замыкание связывается с экземпляром функции вместо его лексического определения. В предыдущем фрагменте существует только одна внутренняя функция addTo(..), определяемая внутри adder(..), поэтому может показаться, что подразумевается только одно замыкание. 

Но в действительности при каждом выполнении внешней функции adder(..) создается новый экземпляр внутренней функции addTo(..) и для каждого нового экземпляра создается новое замыкание. Таким образом, каждый экземпляр внутренней функции (add10To(..) и add42To(..) в нашей программе) содержит собственное замыкание по своему экземпляру области видимости для этого выполнения adder(..). 

И хотя замыкание основано на лексической области видимости, которая обрабатывается во время компиляции, замыкание наблюдается как характеристика экземпляров функций во время выполнения.

#### Живая ссылка, а не снимок

В обоих примерах из предыдущих разделов значение читается из переменной, находящейся в замыкании. При этом может сложиться впечатление, что замыкание представляет собой «моментальный снимок» значения на некоторый момент. Это весьма распространенное заблуждение.

На самом деле замыкание представляет собой живую ссылку, которая сохраняет доступ к полноценной переменной. Вы не ограничиваетесь простым чтением значения; переменную в замыкании также можно обновлять (присваивать ей новое значение). 

Создавая замыкание по переменной в функции, мы можем продолжать пользоваться этой переменной (для чтения и записи), пока ссылка на функцию существует в программе и в любой точке, в которой мы хотим вызвать эту функцию. Вот почему замыкание считается исключительно мощным механизмом, который находит применение во многих областях программирования! 

На рис. 4 изображены связи между экземплярами функций и областями видимости.

![400](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/images/fig4.png?raw=true)

Как видно из рис. 4, каждый вызов adder(..) создает новую область видимости (2), которая содержит переменную num1, а также новый экземпляр функции addTo(..) как область видимости (3). Обратите внимание на то, что экземпляры функций (addTo10(..) и addTo42(..)) присутствуют и вызываются из области видимости (1). 

Рассмотрим пример с обновлением переменной из замыкания:

```js
function makeCounter() {
    var count = 0;

    return function getCurrent() {
        count = count + 1;
        return count;
    };
}

var hits = makeCounter();

// later

hits();     // 1

// later

hits();     // 2
hits();     // 3
```

Переменная count включается в замыкание внутренней функции getCurrent(), которая удерживает эту переменную от уничтожения при сборке мусора. Функция hits() вызывает access и обновляет эту переменную, возвращая увеличенный счетчик при каждом вызове. 

Хотя окружающая область видимости замыкания обычно происходит от функции, в принципе это не обязательно; необходимым условием является лишь наличие внутренней функции во внешней области видимости: 

```js
var hits;
{   // an outer scope (but not a function)
    let count = 0;
    hits = function getCurrent(){
        count = count + 1;
        return count;
    };
}
hits();     // 1
hits();     // 2
hits();     // 3
```

>[!info] Примечание
>Я намеренно определил getCurrent() как функциональное выражение, а не как объявление функции. Это связано не с замыканием, а со странными особенностями FiB (глава 6).

Так как очень легко может возникнуть ошибочное впечатление, что замыкания ориентированы на значения, а не на переменные, разработчики нередко попадают в ловушку, когда пытаются использовать замыкание для фиксации значения на некоторый момент. Пример: 

```js
var studentName = "Frank";

var greeting = function hello() {
    // we are closing over `studentName`,
    // not "Frank"
    console.log(
        `Hello, ${ studentName }!`
    );
}

// later

studentName = "Suzy";

// later

greeting();
// Hello, Suzy!
```

При определении greeting() (т. е. hello()), когда studentName содержит значение "Frank" (перед повторным присваиванием "Suzy"), часто ошибочно предполагается, что замыкание сохранит значение "Frank". Но в замыкание greeting() включается переменная studentName, а не ее значение. При вызове greeting() будет использовано текущее значение переменной ("Suzy" в данном случае). 

Классический пример этой ошибки — определение функций в цикле: 

```js
var keeps = [];

for (var i = 0; i < 3; i++) {
    keeps[i] = function keepI(){
        // closure over `i`
        return i;
    };
}

keeps[0]();   // 3 -WHY!?
keeps[1]();   // 3
keeps[2]();   // 3
```

>[!info] Примечание
>В подобных примерах замыканий обычно используется setTimeout() или другой обратный вызов (например, обработчик события) внутри цикла. Я упростил пример, сохранив ссылки на функции в массиве, чтобы нам не приходилось учитывать асинхронность в своем анализе. Принцип замыкания остается неизменным.

Возможно, вы ожидали, что вызов keeps[0]() вернет 0, так как функция была создана при первой итерации цикла, когда значение i было равно 0. Но и это предположение происходит оттого, что замыкания рассматриваются как ориентированные на значения, а не как ориентированные на переменные. 

Структура цикла for может создать ложное впечатление, что каждая итерация получает собственную новую переменную i; на самом деле в программе существует только одна переменная i, потому что она была объявлена с ключевым словом var. 

Каждая сохраненная функция возвращает 3, потому что к концу цикла единственной переменной i в программе было присвоено значение 3. Каждая из трех функций в массиве keeps имеет индивидуальные замыкания, но все они замыкаются по одной общей переменной i. 

Конечно, одна переменная в любой момент может хранить только одно значение. Таким образом, если вы хотите сохранить на будущее несколько значений, понадобится отдельная переменная для каждого.

Как сделать это в приведенном фрагменте цикла? Создадим новую переменную в каждой итерации:

```js
var keeps = [];

for (var i = 0; i < 3; i++) {
    // new `j` created each iteration, which gets
    // a copy of the value of `i` at this moment
    let j = i;

    // the `i` here isn't being closed over, so
    // it's fine to immediately use its current
    // value in each loop iteration
    keeps[i] = function keepEachJ(){
        // close over `j`, not `i`!
        return j;
    };
}
keeps[0]();   // 0
keeps[1]();   // 1
keeps[2]();   // 2
```

Каждая функция теперь замыкается по отдельной (новой) переменной из каждой итерации, хотя всем им присвоено имя j. И каждой переменной j присваивается копия значения i на тот момент итерации цикла; значение j никогда не изменяется. А значит, теперь все три функции вернут ожидаемые значения: 0, 1 и 2!

И снова следует помнить, что даже если бы в программе использовались асинхронные вызовы (например, передача каждой внутренней функции keepEachJ() при вызове setTimeout(..) или другой разновидности подписки на обработчики событий), будет наблюдаться то же поведение замыканий. 

Вспомните раздел «Циклы» главы 5, который демонстрирует, как объявление let в цикле for создает не только одну переменную для цикла, но и новую переменную для каждой итерации цикла. Этот трюк/странность — именно то, что необходимо для наших замыканий в циклах:

```js
var keeps = [];

for (let i = 0; i < 3; i++) {
    // the `let i` gives us a new `i` for
    // each iteration, automatically!
    keeps[i] = function keepEachI(){
        return i;
    };
}
keeps[0]();   // 0
keeps[1]();   // 1
keeps[2]();   // 2
```

Так как мы используем let, создаются три переменные i, по одной для каждого цикла, и все три замыкания работают именно так, как ожидалось. 

### Типичные замыкания: Ajax и события 

Замыкания чаще всего встречаются при использовании обратных вызовов: 

```js
function lookupStudentRecord(studentID) {
    ajax(
        `https://some.api/student/${ studentID }`,
        function onRecord(record) {
            console.log(
                `${ record.name } (${ studentID })`
            );
        }
    );
}

lookupStudentRecord(114);
// Frank (114)
```

Функция обратного вызова onRecord(..) будет вызвана в какой-то момент в будущем — после того как вернется ответ от вызова Ajax. Этот вызов произойдет во внутренней реализации служебной функции ajax(..), откуда бы она ни была вызвана. Более того, когда это произойдет, вызов lookupStudentRecord(..) уже давно завершится. 

Почему же переменная studentID все еще существует и остается доступной для обратного вызова? Из-за замыкания.

Обработчики событий — еще одно стандартное применение замыканий:

```js
function listenForClicks(btn,label) {
    btn.addEventListener("click",function onClick(){
        console.log(
            `The ${ label } button was clicked!`
        );
    });
}

var submitBtn = document.getElementById("submit-btn");

listenForClicks(submitBtn,"Checkout");
```

Параметр label замыкается из обратного вызова обработчика событий onClick(..). При нажатии кнопки label все еще существует и может использоваться. И это объясняется замыканием. 

#### А если я не вижу?

Вероятно, вы слышали этот часто встречающийся философский вопрос: раздается ли в лесу звук падающего дерева, если в лесу никого нет? 

На самом деле это глупая философская эквилибристика. Конечно, с научной точки зрения звуковые волны создаются. Но суть в другом: имеет ли значение, издается звук или нет? 

Вспомните, что в нашем определении особое внимание уделялось наблюдаемости. Если замыкание существует (в техническом, реализационном или академическом смысле), но не может наблюдаться в наших программах, имеет ли это значение? Нет.

Чтобы подчеркнуть этот момент, рассмотрим несколько примеров, не основанных на замыканиях с возможностью наблюдения. 

Начнем с вызова функции, использующей поиск по лексическим областям вызова:

```js
function say(myName) {
    var greeting = "Hello";
    output();

    function output() {
        console.log(
            `${ greeting }, ${ myName }!`
        );
    }
}

say("Kyle");
// Hello, Kyle!
```

Внутренняя функция output() обращается к переменным greeting и myName из окружающей области видимости. Но вызов output() происходит в той же области видимости, в которой, конечно, greeting и myName все еще доступны; это просто лексическая область видимости, а не замыкание.

Любой язык с лексической областью видимости, функции которого не поддерживают замыкания, будет вести себя так же.

Более того, переменные глобальной области видимости не могут (наблюдаемо) участвовать в замыканиях, потому что они всегда доступны в любой точке. Никакая функция не может вызываться в любой части цепочки областей видимости, которая бы не являлась потомком глобальной области видимости. 

Пример:

```js
var students = [
    { id: 14, name: "Kyle" },
    { id: 73, name: "Suzy" },
    { id: 112, name: "Frank" },
    { id: 6, name: "Sarah" }
];

function getFirstStudent() {
    return function firstStudent(){
        return students[0].name;
    };
}

var student = getFirstStudent();

student();
// Kyle
```

Внутренняя функция firstStudent() обращается к students — переменной за пределами ее собственной области видимости. Но так как students находится в глобальной области видимости, неважно, где эта функция вызывается в программе; ее способность обращаться к students — не что иное, как обычная лексическая область видимости. 

Все вызовы функций могут обращаться к глобальным переменным независимо от того, поддерживаются ли замыкания языком или нет. Глобальные переменные просто не нужно включать в замыкания. 

Переменные, которые просто присутствуют, но к которым не происходят обращения, не приводят к созданию замыканий: 

```js
function lookupStudent(studentID) {
    return function nobody(){
        var msg = "Nobody's here yet.";
        console.log(msg);
    };
}

var student = lookupStudent(112);

student();
// Nobody's here yet.
```

Внутренняя функция nobody() не замыкается ни по каким внешним переменным — она использует только свою собственную переменную msg. И хотя studentID присутствует в окружающей области видимости, nobody() не обращается к studentID. Движку  не нужно поддерживать существование studentID после завершения выполнения lookupStudent(..), поэтому система сборки мусора захочет освободить эту память!

Эта программа вела бы себя одинаково независимо от того, поддерживают ли функции  замыкания или нет. Следовательно, наблюдаемых замыканий здесь нет. 

При отсутствии вызова функции замыкание также не наблюдается:

```js
function greetStudent(studentName) {
    return function greeting(){
        console.log(
            `Hello, ${ studentName }!`
        );
    };
}

greetStudent("Kyle");

// nothing else happens
```

С этим примером все хитрее, потому что внешняя функция определенно вызывается. Но именно внутренняя функция может иметь замыкание, однако она никогда не вызывается; возвращенная функция здесь просто теряется. Таким образом, хотя формально движок  создает замыкание на очень короткое время, оно не наблюдается в программе никаким осмысленным образом. 

Возможно, дерево упало… Но мы этого не слышали, поэтому нас это совершенно не интересует. 

#### Наблюдаемое определение

Теперь все готово для определения замыкания.

Замыкание наблюдается тогда, когда функция использует переменную(-ые) из другой(-их) области(-ей) видимости даже при выполнении в области видимости, в которой эта(-и) пере менная(-ые) должна(ы) быть недоступна(-ы). 

Ключевые части определения:

в замыкании должна быть задействована функция;
она должна обращаться хотя бы к одной переменной из внешней области видимости;
функция должна вызываться из другой ветви цепочки областей видимости относительно той, в которой находи(-я)тся переменная(-ые). 

Определение, ориентированное на наблюдаемость, означает, что мы не должны отбрасывать замыкания, как какую-то теоретическую, не имеющую практической ценности безделушку. Вместо этого следует выявлять и планировать прямые, конкретные эффекты замыканий для поведения наших программ.

### Жизненный цикл замыканий и сборка мусора (GC)
`название главы The Closure Lifecycle and Garbage Collection (GC)`

Так как замыкания неразрывно связаны с экземпляром функции, ее замыкание по переменной продолжается до тех пор, пока существует ссылка на эту функцию. 

Если десять функций замыкаются по одной и той же переменной и со временем девять из этих ссылок на функции исчезают, то одна оставшаяся ссылка на функцию продолжит сохранять эту переменную в памяти. Как только последняя ссылка на функцию будет потеряна, последнее замыкание по этой переменной пропадает и сама переменная освобождается сборщиком мусора. 

Это имеет важные последствия для построения эффективных и производительных программ. Замыкание может неожиданно помешать освобождению переменной, с которой вы уже завершили работу, что приводит к утечке памяти со временем. Вот почему важно освобождать ссылки на функции (а следовательно, и их замыкания), когда они перестают быть ненужными. 

Пример:

```js
function manageBtnClickEvents(btn) {
    var clickHandlers = [];

    return function listener(cb){
        if (cb) {
            let clickHandler =
                function onClick(evt){
                    console.log("clicked!");
                    cb(evt);
                };
            clickHandlers.push(clickHandler);
            btn.addEventListener(
                "click",
                clickHandler
            );
        }
        else {
            // passing no callback unsubscribes
            // all click handlers
            for (let handler of clickHandlers) {
                btn.removeEventListener(
                    "click",
                    handler
                );
            }

            clickHandlers = [];
        }
    };
}

// var mySubmitBtn = ..
var onSubmit = manageBtnClickEvents(mySubmitBtn);

onSubmit(function checkout(evt){
    // handle checkout
});

onSubmit(function trackAction(evt){
    // log action to analytics
});

// later, unsubscribe all handlers:
onSubmit();
```

В этой программе внутренняя функция onClick(..) поддерживает замыкание по полученному значению cb (предоставляемый обратный вызов события). Это означает, что ссылки на функциональные выражения checkout() и trackAction() удерживаются посредством замыкания (и не могут быть освобождены сборщиком мусора), пока эти обработчики событий остаются зарегистрированными для подписки.

Когда мы вызываем onSubmit() без входных данных в последней строке, подписка всех обработчиков событий отменяется и массив clickHandlers очищается. После того как все ссылки на функцииобработчики освобождаются, замыкания ссылок cb на checkout() и trackAction() освобождаются. 

При анализе общего рабочего состояния и эффективности программы отмена подписки на обработчик событий, когда надобность в нем отпадет, может быть даже важнее исходной подписки! 

#### На уровне переменных или на уровне области видимости? 

Другой вопрос, которому необходимо уделить внимание: следует ли считать, что замыкание применяется только к тем внешним переменным, к которым вы обращаетесь, или же оно сохраняет всю цепочку областей видимости со всеми ее переменными?

Иначе говоря, в предыдущем фрагменте с подпиской на события замыкается ли внутренняя функция onClick(..) только на cb или же она также замыкается на clickHandler, clickHandlers и btn? 

На концептуальном уровне замыкание работает на уровне переменных, а не области видимости. Обычно считается, что обратные вызовы Ajax, обработчики событий и все остальные формы функциональных замыканий обычно замыкаются только по тем переменным, к которым они явно обращаются. 

Но реальность немного сложнее.

Рассмотрим еще один пример:

```js
function manageStudentGrades(studentRecords) {
    var grades = studentRecords.map(getGrade);

    return addGrade;

    // ************************

    function getGrade(record){
        return record.grade;
    }

    function sortAndTrimGradesList() {
        // sort by grades, descending
        grades.sort(function desc(g1,g2){
            return g2 g1;
        });

        // only keep the top 10 grades
        grades = grades.slice(0,10);
    }

    function addGrade(newGrade) {
        grades.push(newGrade);
        sortAndTrimGradesList();
        return grades;
    }
}

var addNextGrade = manageStudentGrades([
    { id: 14, name: "Kyle", grade: 86 },
    { id: 73, name: "Suzy", grade: 87 },
    { id: 112, name: "Frank", grade: 75 },
    // ..many more records..
    { id: 6, name: "Sarah", grade: 91 }
]);

// later

addNextGrade(81);
addNextGrade(68);
// [ .., .., ... ]
```

Внешняя функция manageStudentGrades(..) получает список записей с данными студентов и возвращает ссылку на функцию addGrade(..), которой мы присвоим внешнюю метку addNextGrade(..). При каждом вызове addNextGrade(..) с новой оценкой мы получаем текущий список 10 наивысших оценок, отсортированный по убыванию (см. sortAndTrimGradesList()). 

От конца исходного вызова manageStudentGrades(..) и между несколькими вызовами addNextGrade(..) переменная grades сохраняется внутри addGrade(..) посредством замыканий; так поддерживается текущий список наивысших оценок. Помните: в замыкание включается сама переменная grades, а не содержащийся в ней массив. 

Впрочем, это не единственное задействованное замыкание. Заметите ли вы другие переменные, включенные в замыкание? 

Вы заметили, что addGrade(..) обращается к переменной sortAndTrimGradesList? Это означает, что она также замыкается по этому идентификатору, в котором хранится ссылка на функцию sortAndTrimGradesList(). Вторая внутренняя функция должна продолжить существование, чтобы функция addGrade(..) могла продолжать вызывать ее, а это означает, что все замыкаемые ей переменные тоже должны сохраняться, хотя в этом конкретном случае ничего лишнего в замыкание не включается. 

Что еще включается в замыкание? 

Возьмем переменную getGrade (и ее функцию); она включается в замыкание? Обращение к ней происходит во внешней области видимости manageStudentGrades(..) при вызове .map(getGrade). При этом к ней нет обращений из addGrade(..) или sortAndTrimGradesList(). 

Как насчет (потенциально) большого списка записей студентов, передаваемого в studentRecords? Эта переменная включается в замыкание? Если включается, то массив записей студентов никогда не будет освобожден сборщиком мусора и в результате программа будет расходовать больше памяти, чем можно было ожидать. Но если присмотреться повнимательнее, ни одна из внутренних функций не обращается к studentRecords. 

В соответствии с определением замыканий на уровне переменных, так как внутренние функции не обращаются к getGrade и studentRecords, они не включаются в замыкание. Они должны быть доступны для сборки мусора непосредственно после завершения вызова manageStudentGrades(..). 

Попробуйте отладить этот код в новом движке  (например, v8 в Chrome) и установить точку прерывания в функции addGrade(..). Возможно, вы заметите, что в инспекторе отсутствует переменная studentRecords. Это служит доказательством (по крайней мере, с точки зрения отладки), что движок не хранит studentRecords через замыкание. 

Но в какой мере это наблюдение может служить доказательством? Возьмем 
следующую (довольно неестественную) программу:

```js
function storeStudentInfo(id,name,grade) {
    return function getInfo(whichValue){
        // warning:
        //   using `eval(..)` is a bad idea!
        var val = eval(whichValue);
        return val;
    };
}

var info = storeStudentInfo(73,"Suzy",87);

info("name");
// Suzy

info("grade");
// 87
```

Обратите внимание: внутренняя функция getInfo(..) не включает явно в замыкание переменные id, name или grade. Но вызовы info(..) вроде бы все равно могут обращаться к переменным, хотя и через трюк с лексической областью видимости с eval(..) (см. главу 1).

Получается, что все переменные определенно сохраняются через замыкание, хотя и внутренняя функция не содержит явных обращений к ней. Выходит, это опровергает утверждение о замыканиях уровня переменных в пользу замыканий уровня областей видимости? Зависит от обстоятельств. 

Многие современные движки  применяют оптимизацию, которая исключает из области видимости замыкания любые переменные, к которым отсутствуют явные обращения. Но как показывает пример с eval(..), в некоторых ситуациях такая оптимизация неприменима и область видимости замыкания включает все исходные переменные. Другими словами, замыкание должно существовать на уровне области видимости (в зависимости от реализации), после чего необязательная оптимизация усекает область видимости до замыкаемых переменных (результат, эквивалентный замыканиям с уровнем переменных). 

Даже несколько лет назад многие движки  не применяли эту оптимизацию; возможно, ваши веб-сайты все еще работают в таких браузерах (особенно на старых или малопроизводительных устройствах). Это означает, что замыкания с долгим сроком жизни (например, обработчики событий) могут находиться в памяти намного дольше, чем можно было бы ожидать. 

И тот факт, что речь идет о необязательной оптимизации, а не о требовании спецификации, означает, что мы не должны строить излишних ожиданий относительно ее применимости. 

В тех случаях, когда переменная из области видимости замыкания содержит большое значение (например, объект или массив) и вы не хотите, чтобы эта память удерживалась, будет безопаснее (с точки зрения расходования памяти) вручную освободить значение, вместо того чтобы полагаться на оптимизацию замыканий/сборку мусора. 

Внесем изменение в более ранний пример manageStudentGrades(..), чтобы потенциально большой массив из studentRecords не удерживался в области видимости замыкания без необходимости:

```js
function manageStudentGrades(studentRecords) {
    var grades = studentRecords.map(getGrade);

    // unset `studentRecords` to prevent unwanted
    // memory retention in the closure
    studentRecords = null;

    return addGrade;
    // ..
}
```

Мы не удаляем studentRecords из области видимости замыкания — это не в наших силах. Мы гарантируем, что даже если studentRecords останется в области видимости замыкания, эта переменная уже не ссылается на потенциально большой массив данных; массив может быть уничтожен в ходе сборки мусора. 

Еще раз: во многих случаях  может автоматически оптимизировать программу для достижения того же эффекта. Тем не менее стоит обзавестись полезной привычкой и явно следить за тем, чтобы значительный объем памяти устройства не оставался зарезервированным дольше, чем необходимо. 

Собственно говоря, формально функция getGrade() также не нужна нам после завершения вызова .map(getGrade). Если профилирование приложения показывает, что затраты памяти критичны для приложения, мы можем освободить еще немного памяти, освобождая эту ссылку, чтобы ее значение не оставалось в памяти. Скорее всего, это совершенно излишне в этом учебном примере, но стоит знать этот общий прием, если вы занимаетесь оптимизацией затрат памяти в приложениях. 

Вывод: важно знать, где в наших программах появляются замыкания и какие переменные в них включаются. Следует тщательно управлять этими замыканиями, чтобы в памяти удерживался минимально необходимый объем памяти, а память не расходовалась понапрасну. 
### Альтернативная точка зрения 

В нашем рабочем определении замыканий предполагается, что эти функции являются «полноправными значениями», которые могут передаваться в программах, как и любые другие значения. Замыкание представляет собой ссылочную связь, которая соединяет эту функцию с областями видимости/переменными за ее пределами независимо от того, где находится эта функция. 

Вспомним приводившийся ранее в этой главе пример кода с цветовой пометкой областей видимости:

```js
// outer/global scope: RED(1)

function adder(num1) {
    // function scope: BLUE(2)

    return function addTo(num2){
        // function scope: GREEN(3)

        return num1 + num2;
    };
}

var add10To = adder(10);
var add42To = adder(42);

add10To(15);    // 25
add42To(9);     // 51
```

Наша текущая точка зрения предполагает, что при каждой передаче и вызове функции замыкание сохраняет скрытую ссылку на исходную область видимости, чтобы упростить доступ к переменным из замыкания. На рис. 4, повторенном для удобства, показан этот принцип.

![400](https://github.com/getify/You-Dont-Know-/blob/2nd-ed/scope-closures/images/fig4.png?raw=true)

Но есть другой взгляд на замыкания — точнее, на природу передаваемых функций, который может углубить ваши ментальные модели. 

Эта альтернативная модель уводит на второй план концепцию функций как полноправных значений и вместо этого уделяет основное внимание тому, как функции (как и все непримитивные значения) хранятся в  по ссылке и присваиваются/передаются копированием ссылки; за дополнительной информацией обращайтесь к приложению А книги «Познакомьтесь, JavaScript». 

Чтобы не рассматривать перемещение экземпляра внутренней функции addTo(..) во внешнюю область видимости КРАСНЫЙ (1) командой return и присваиванием, мы можем представить, что экземпляры функций на самом деле остаются на месте со своей собственной средой области видимости — конечно, с сохранением цепочки областей видимости. В область видимости КРАСНЫЙ (1) передается только ссылка на экземпляр функции, а не сам экземпляр функции. На рис. 5 изображены экземпляры внутренней функции, остающиеся на своих местах, на которые указывают ссылки КРАСНЫЙ (1) addTo10 и addTo42 соответственно:

![450](https://github.com/getify/You-Dont-Know-/blob/2nd-ed/scope-closures/images/fig5.png?raw=true)

Как показано на рис. 5, каждый вызов adder(..) все еще создает новую область видимости СИНИЙ (2), содержащую переменную num1, а также экземпляр области видимости ЗЕЛЕНЫЙ (3) addTo(..). Но в отличие от рис. 4, теперь эти экземпляры ЗЕЛЕНЫЙ (3) остаются на месте, оставаясь вложенными естественным образом в свои экземпляры области видимости СИНИЙ (2). Во внешнюю область видимости КРАСНЫЙ (1) перемещаются ссылки addTo10 и addTo42, а не сами экземпляры функций.

При вызове addTo10(15) вызывается экземпляр функции addTo(..) (все еще остающийся на месте в своей исходной области видимости СИНИЙ (2)). Так как сам экземпляр функции никуда не перемещается, конечно, он сохраняет естественный доступ к своей цепочке областей видимости. То же относится к вызову add-To42(9) — в нем нет ничего необычного, выходящего за рамки лексической видимости. 

Тогда что же такое замыкание, если не волшебство, которое позволяет функции поддерживать ссылку на исходную цепочку областей видимости, даже если эта функция перемещается в другие области видимости? В этой альтернативной модели функции остаются на месте и продолжают обращаться к своей исходной цепочке областей видимости, которая всегда была для них доступна.

Здесь замыкание скорее становится волшебством, которое позволяет поддерживать существование экземпляра функции вместе со всей его областью видимости и цепочкой, пока в программе остается хотя бы одна ссылка на этот экземпляр функции, существующий в любой другой части программы. 

Такое определение замыкания в меньшей степени ориентировано на наблюдаемые эффекты и звучит чуть менее знакомо по сравнению с традиционными академическими представлениями. Тем не менее оно остается полезным, потому объяснение сути замыкания упрощается до прямолинейной комбинации ссылок и экземпляров функций, остающихся на своих местах. 

Нельзя сказать, что предыдущая модель (рис. 4) ошибочно описывает замыкание в . Просто она чуть более концептуальна — это теоретическая точка зрения на замыкания. С другой стороны, альтернативную модель (рис. 5) можно описать как в большей степени ориентированную на реализацию — на то, как реально работает . 

Обе точки зрения/модели полезны для понимания замыканий, но, возможно, какая-то из них покажется читателю более понятной. Какую бы вы ни выбрали, наблюдаемые эффекты в программе остаются одними и теми же. 

>[!info] Примечание
>Альтернативная модель замыканий влияет на то, можно ли отнести синхронные обратные вызовы к примерам замыканий или нет. Подробнее этот нюанс рассматривается в приложении А. 

### Для чего нужны замыкания?

Теперь, когда вы получили разностороннее представление о том, что такое замыкания и как они работают, рассмотрим некоторые возможности того, как они могут улучшить структуру кода и организацию программ-примеров. 

Представьте, что на странице находится кнопка, которая при нажатии должна прочитать и отправить некоторые данные при помощи запроса Ajax. 

Без использования замыканий:

```js
var APIendpoints = {
    studentIDs:
        "https://some.api/register-students",
    // ..
};

var data = {
    studentIDs: [ 14, 73, 112, 6 ],
    // ..
};

function makeRequest(evt) {
    var btn = evt.target;
    var recordKind = btn.dataset.kind;
    ajax(
        APIendpoints[recordKind],
        data[recordKind]
    );
}

// <button data-kind="studentIDs">
//    Register Students
// </button>
btn.addEventListener("click",makeRequest);
```

Функция makeRequest(..) получает от события щелчка только объект evt. Она должна получить атрибут data-kind целевого элемента кнопки и использовать это значение для получения как URL-адреса для конечной точки API, так и данных, которые должны быть включены в запрос Ajax. 

Такое решение работает, но, к сожалению, обработчик события должен читать атрибут DOM при каждом срабатывании. Почему бы обработчику события не запомнить это значение? Попробуем воспользоваться замыканием для улучшения кода: 

```js
var APIendpoints = {
    studentIDs:
        "https://some.api/register-students",
    // ..
};

var data = {
    studentIDs: [ 14, 73, 112, 6 ],
    // ..
};

function setupButtonHandler(btn) {
    var recordKind = btn.dataset.kind;

    btn.addEventListener(
        "click",
        function makeRequest(evt){
            ajax(
                APIendpoints[recordKind],
                data[recordKind]
            );
        }
    );
}

// <button data-kind="studentIDs">
//    Register Students
// </button>

setupButtonHandler(btn);
```

С подходом setupButtonHandler(..) атрибут data-kind читается только один раз, а затем присваивается переменной recordKind при начальной инициализации. Затем recordKind включается в замыкание для внутреннего обработчика makeRequest(..), и его значение используется при каждой выдаче события для поиска URL и данных, которые требуется отправить. 

>[!info] Примечание
>Объект evt все еще передается makeRequest(..), хотя мы его более не используем. Он все еще указывается для сохранения логической целостности с предыдущим фрагментом.


Размещая recordKind внутри setupButtonHandler(..), мы ограничиваем раскрытие этой переменной более подходящим подмножеством программы; ее глобальное хранение ухудшило бы структуру и удобочитаемость кода. Замыкание позволяет экземпляру внутренней функции makeRequest() запомнить эту переменную и обращаться к ней при необходимости. 

Развивая этот паттерн, мы можем определить URL и данные одновременно при инициализации:

```js
function setupButtonHandler(btn) {
    var recordKind = btn.dataset.kind;
    var requestURL = APIendpoints[recordKind];
    var requestData = data[recordKind];

    btn.addEventListener(
        "click",
        function makeRequest(evt){
            ajax(requestURL,requestData);
        }
    );
}
```

Теперь makeRequest(..) замыкается на requestURL и requestData; такое решение немного проще понять, и оно также обладает чуть лучшим быстродействием.

Два сходных приема из парадигмы функционального программирования (FP), зависящие от замыканий, — частичное применение и каррирование. Вкратце: в этих приемах изменяется форма функций, получающих несколько входных значений, чтобы некоторые входные данные предоставлялись заранее, а другие — позднее; исходные входные данные запоминаются через замыкание. После того как все входные данные будут предоставлены, выполняется соответствующее действие.

Создавая экземпляр функции, который инкапсулирует некоторую информацию (посредством замыкания), функция с хранимой информацией может использоваться позднее напрямую без повторной передачи этих входных данных. Это способствует упрощению кода, а также предоставляет возможность назначения частично применяемым функциям более содержательных семантических имен. 

Адаптированная версия частичного применения позволяет дополнительно улучшить этот код:

```js
function defineHandler(requestURL,requestData) {
    return function makeRequest(evt){
        ajax(requestURL,requestData);
    };
}

function setupButtonHandler(btn) {
    var recordKind = btn.dataset.kind;
    var handler = defineHandler(
        APIendpoints[recordKind],
        data[recordKind]
    );
    btn.addEventListener("click",handler);
}
```

Входные данные requestURL и requestData предоставляются заранее, в результате чего создается частично примененная функция makeRequest(..), которой мы присваиваем локальную метку handler. Когда событие сработает, handler() передается последнее входное значение (evt, хотя в данном случае оно игнорируется), и после сбора всех входных данных инициируется запрос Ajax. 

В отношении поведения эта программа очень похожа на предыдущую, и она использует такой же тип замыкания. Однако выделение создания makeRequest() в отдельную вспомогательную функцию (defineHandler(..)) упрощает повторное использование этого определения в программе. Мы также явно ограничиваем область видимости замыкания двумя необходимыми переменными. 

### Напоследок о замыканиях 

Приближаясь к концу довольно насыщенной главы, переведите дыхание и попытайтесь осознать все сказанное. Не каждому под силу усвоить такой объем информации за раз! 

В этой главе были рассмотрены две концептуальные модели замыканий:

Основанная на наблюдаемости: замыкание — экземпляр функции, запоминающей свои внешние переменные даже при ее передаче и вызове в других областях видимости.
Основанная на реализации: замыкание — экземпляр функции и окружение ее области видимости, хранящиеся «на месте»; ссылки на эту функцию передаются и вызываются в других областях видимости. 

Основные преимущества замыканий для наших программ.

Замыкание может повысить эффективность, так как экземпляр функции может запомнить ранее определенную информацию, вместо того чтобы каждый раз вычислять ее заново. 
Замыкания могут улучшить удобочитаемость кода. Они ограничивают раскрытие за счет инкапсуляции переменной(-ых) внутри экземпляров функции, при этом сохраняя на будущее возможность доступа к информации в этих переменных. С полученными более узкими, более специализированными экземплярами функций проще взаимодействовать, так как хранимую информацию не нужно передавать при каждом вызове.

Прежде чем двигаться дальше, выделите немного времени на то, чтобы пересказать итоги своими словами. Объясните, что такое замыкание и почему оно может пригодиться в ваших программах. А нам осталась последняя глава, в которой на базе замыканий будет построен паттерн «Модуль». 

[^1]: хитрая приманка, зверя либо жертвы, который думает что поживится, а на самом деле оказывается жертвой
	

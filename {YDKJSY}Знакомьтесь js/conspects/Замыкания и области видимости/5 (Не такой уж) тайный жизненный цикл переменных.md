Теперь вы должны достаточно хорошо понимать концепцию вложенности от глобальной области видимости вниз — так называемой цепочки областей видимости программы. 
Но просто знать, из какой области видимости происходит переменная, недостаточно. Если объявление переменной следует после первой команды в области видимости, как будут вести себя ссылки на этот идентификатор до его объявления? Что произойдет, если попытаться дважды объявить одну переменную в области видимости? 
Особая разновидность лексических областей видимости в `JS` богата нюансами в том, как и когда переменные начинают свое существование и становятся доступными для программы.

### Когда можно использовать переменную?
В какой момент переменная становится доступной для использования внутри своей области видимости? Казалось бы, ответ очевиден: после того, как переменная была объявлена/создана. Правильно? Не совсем. 
Пример:

```js
greeting(); // Hello!
function greeting() { console.log("Hello!"); }
```

Этот код работает нормально. Возможно, вы уже видели или даже писали нечто подобное. Но вы когда-нибудь задумывались над тем, как и почему он работает? А если конкретно, почему вы можете обратиться к идентификатору greeting из строки 1 (для получения и выполнения ссылки на функцию), хотя объявление функции greeting() происходит только в строке 4?

Вспомните: в главе 1 я говорил, что все идентификаторы регистрируются в соответствующих областях видимости во время компиляции. Более того, каждый идентификатор создается в начале той области видимости, которой он принадлежит, при каждом входе в эту область видимости. 

Ситуация, при которой переменная видима от начала своей вмещающей области видимости, несмотря на то что ее объявление может находиться ниже в области видимости, называется поднятием (hoisting).

Тем не менее одно лишь поднятие не дает полного ответа на вопрос. Идентификатор greeting виден от начала области видимости, но почему мы можем использовать функцию greeting() еще до того, как она была объявлена? 

Другими словами, как переменной greeting может быть присвоено значение (ссылка на функцию) с момента выполнения области видимости? Ответ кроется в специальной характеристике формальных объявлений function, называемой поднятием функций. Когда идентификатор объявления function регистрируется в начале своей области видимости, он дополнительно автоматически инициализируется ссылкой на эту функцию. Вот почему функция может вызываться во всей области видимости!

Одна ключевая подробность заключается в том, что и поднятие функции, и поднятие var-переменных связывают свои идентификаторы с ближайшей вмещающей областью видимости функции (а если ее нет — глобальной областью видимости), а не с блоковой областью видимости.

Объявления с let и const тоже поднимаются (см. часть о TDZ далее в этой главе). Но эти две формы объявлений связываются со своим вмещающим блоком, а не с вмещающей функцией, как в случае с объявлениями var и function. За дополнительной информацией обращайтесь к разделу «Области видимости и блоки» главы 6.

#### Поднятие: объявления и выражения

Поднятие функций применяется только к формальным объявлениям функций (а конкретно тех, которые располагаются вне блоков — см. раздел FiB главы 6), но не к присваиваниям функциональных выражений.

Пример:

```js
greeting(); // TypeError 
var greeting = function greeting() { console.log("Hello!"); };
```

В строке 1 (greeting();) происходит ошибка. И очень важно заметить разновидность этой ошибки. TypeError означает, что мы пытаемся что-то сделать с недопустимым значением. В зависимости от вашей среды `JS` в сообщении об ошибке может быть сказано что-то вроде «‘undefined’ не является функцией» или в более содержательном варианте — «‘greeting’ не является функцией». 

Обратите внимание: программа не выдает ошибку ReferenceError. `JS` не говорит, что найти идентификатор в области видимости не удалось. `JS` говорит, что идентификатор greeting был найден, но в данный момент он не содержит ссылки на функцию. Вызываться могут только функции, поэтому попытка вызова для любого значения, не являющегося функцией, приводит к ошибке. 

Но что же содержит greeting, если не ссылку на функцию? Кроме поднятия, переменные, объявленные с ключевым словом var, также автоматически инициализируются undefined в начале своей области видимости — это снова ближайшая вмещающая или глобальная область видимости. После инициализации они доступны для использования (присваивания, чтения и т. д.) во всей области видимости.

Таким образом, в первой строке greeting существует, но содержит только значение по умолчанию undefined. Только в строке 4 greeting будет присвоена ссылка на функцию.

Обратите особое внимание на это отличие. Объявление функции поднимается и инициализируется своим значением функции (еще раз: это называется поднятием функции). Переменная var тоже поднимается и автоматически инициализируется undefined. Все последующие присваивания функциональных выражений этой переменной не выполняются до того момента, когда это присваивание будет обработано во время выполнения. 

В обоих случаях идентификатор (имя) поднимается. Но связывание ссылки на функцию не обрабатывается во время инициализации (начало области видимости), если только идентификатор не был создан в формальном объявлении function

#### Поднятие переменной 

Рассмотрим еще один пример поднятия переменной:
```js
greeting = "Hello!";
console.log(greeting); // Hello!
 var greeting = "Howdy!"; 
```

И хотя идентификатор greeting не объявляется до строки 4, он доступен для присваивания уже в строке 1. Почему? У объяснения есть две необходимые составляющие:

идентификатор поднимается; 
он автоматически инициализируется значением undefined в начале области видимости.

>[!info] Примечание
>Вероятно, подобное использование поднятия переменных выглядит неестественно, и многие читатели с полным основанием предпочтут избегать его в своих программах. Но следует ли избегать всего поднятия (включая поднятие функций)? Разные точки зрения на поднятие будут более подробно рассмотрены в приложении А.

### Поднятие: еще одна метафора

[[2. Лексическая видимость|Глава 2]]  была полна метафор (для демонстрации областей видимости), но здесь мы сталкиваемся еще с одной — самим поднятием (hoisting). Не будем представлять поднятие как конкретный шаг, выполняемый движком `JS` на стадии выполнения, а рассмотрим его как наглядное представление различных действий, выполняемых движком `JS` при подготовке программы до выполнения. 

Как правило, термин «поднятие» вызывает ассоциации с поднятием тяжестей — т. е. любых идентификаторов до самого верха области видимости. В объяснениях часто утверждается, что движок `JS` фактически перезаписывает программу перед выполнением, так что в результате она выглядит примерно так:

```js
var greeting; // поднятое объявление
greeting = "Hello!"; // исходная строка 1
 console.log(greeting); // Hello! 
 greeting = "Howdy!"; // `var` исчезает! 
```

Поднятие (метафора) предполагает, что `JS` осуществляет предварительную обработку исходной программы и немного переупорядочивает его, так что все объявления перемещаются в начало соответствующих областей видимости перед выполнением. Более того, метафора поднятия утверждает, что все объявления функций полностью поднимаются в начало своих областей видимости. 
Пример:

```js
studentName = "Suzy";
greeting(); // Hello Suzy!
function greeting() { console.log(`Hello ${ studentName }!`); }
 var studentName;
```

«Правило» метафоры поднятия гласит, что объявления функций поднимаются первыми, а затем после всех функций немедленно поднимаются переменные. Таким образом, поднятие предполагает, что программа переупорядочивается движком `JS` так, чтобы она пришла к следующему виду:

```js
function greeting() { console.log(`Hello ${ studentName }!`); }
 var studentName;
  studentName = "Suzy"; 
  greeting(); // Hello Suzy
```

Метафора поднятия удобна. Она позволяет выполнить опережающую предварительную обработку, необходимую для нахождения всех этих объявлений, зарытых где-то глубоко в областях видимости, и каким-то волшебным образом поднять (переместить) их в начало; всю программу можно рассматривать так, словно она выполняется движком `JS` сверху вниз за один проход.

Однопроходная обработка определенно выглядит более понятно, чем двухфазная обработка, упоминавшаяся в главе 1. 

Поднятие как механизм переупорядочения кода — привлекательное упрощенное представление, но оно неточно. Движок `JS` не осуществляет фактической перестановки кода. Оно не может по волшебству заглянуть вперед и найти объявления; точно определить их (а также все границы областей видимости в программе) можно только одним способом — полным разбором кода. 

Угадайте, о каком разборе идет речь? О первой фазе двухфазной обработки! И никакие словесные ухищрения не обойдут этот факт. 

Таким образом, если метафора поднятия (в лучшем случае) неточна, что же делать с этим термином? Я думаю, что он остается полезным — даже участники TC39 регулярно пользуются им! — но мы не можем утверждать, что он представляет фактическое переупорядочение исходного кода.

> [!info] Примечание
> Неправильные или неполные ментальные модели часто кажутся адекватными, потому что они в отдельных случаях приводят к правильным ответам. Но в долгосрочной перспективе вам будет труднее анализировать и прогнозировать результаты, если ваши внутренние представления расходятся с тем, как реально работает движок `JS`.

Я считаю, что термин «поднятие» следует использовать для обозначения выполняемой во время компиляции операции генерирования команд для автоматической регистрации переменной в начале ее области видимости при каждом входе в эту область видимости. Это тонкий, но важный переход от поднятия как поведения времени выполнения до его более подобающего места среди задач времени компиляции. 
### Повторное объявление?

Как вы думаете, что произойдет при многократном объявлении переменной в той же области видимости? Пример:

```js
var studentName = "Frank";
console.log(studentName); // Frank 
var studentName;
console.log(studentName); // ???
```

Что, по вашему мнению, будет выведено во втором сообщении? Многие разработчики считают, что второе вхождение var studentName объявляет переменную заново (и при этом «сбрасывает» ее), поэтому команда должна вывести undefined.

Но существует ли такое явление, как повторное объявление переменной в одной области видимости? Нет.

Если рассматривать программу с точки зрения метафоры поднятия, этот код можно было бы переупорядочить в следующем виде для целей выполнения:

```js
var studentName; 
var studentName; // очевидно бессмысленная пустая операция!
studentName = "Frank"; 
console.log(studentName); // Frank
console.log(studentName); // Frank
```

Так как суть поднятия в действительности заключается в регистрации переменной в начале области видимости, если исходная программа содержит вторую команду var studentName, в середине области видимости ничего делать не придется. По сути это пустая операция; такая команда не имеет смысла.

>[!info] Примечание
>Если продолжить метафору диалога из главы 2, Компилятор найдет вторую команду var и спросит Менеджера области видимости, встречался ли ему идентификатор studentName; так как идентификатор уже встречался, ничего делать не нужно. 

Также важно заметить, что var studentName; не означает var studentName = undefined;, как считают многие. Чтобы доказать, что это не одно и то же, рассмотрим следующую разновидность программы:

```js
var studentName = "Frank";
 console.log(studentName); // Frank 
 var studentName; 
 console.log(studentName); // Frank <--все равно! // добавим явную инициализацию 
 var studentName = undefined;
  console.log(studentName); // undefined <--видите!?
```

Как видите, явная инициализация = undefined дает другой результат, чем предположение о том, что она выполняется неявно при ее отсутствии. В следующем разделе мы вернемся к теме инициализации переменных по их объявлениям.

Повторное объявление var с тем же именем идентификатора в области видимости фактически является пустой операцией. Другая иллюстрация — на этот раз через функцию с тем же именем:

```js
var greeting; function greeting() { console.log("Hello!"); } // по сути пустая операция 
var greeting; 
typeof greeting; // "function" 
var greeting = "Hello!";
 typeof greeting; // "string"
```

Первое объявление greeting регистрирует идентификатор в области видимости, а так как это объявление var, оно будет автоматически инициализировано undefined. Объявлению function не нужно заново регистрировать идентификатор, но из-за поднятия функций оно переопределяет автоматическую инициализацию для использования ссылки на функцию. Второе объявлениеvar greeting само по себе ничего не делает, потому что greeting уже является идентификатором, а поднятие функции уже имеет приоритет перед автоматической инициализацией.

На самом деле присваивание "Hello!" переменной greeting заменяет ее значение (исходную функцию greeting()) строкой; само по себе объявление var никакого эффекта не имеет. Как насчет повторения объявлений в области видимости с использованием let или const?

```js
let studentName = "Frank";
console.log(studentName);
let studentName = "Suzy";
```

Программа не будет выполняться, но вместо этого немедленно выдаст ошибку SyntaxError. В зависимости от среды `JS` сообщение об ошибке может включать сообщение вида «имя studentName уже было объявлено». Иначе говоря, это тот случай, когда попытка повторного объявления явно запрещена! 

Дело даже не в том, что с двумя объявлениями, использующими let, произойдет эта ошибка. Если хотя бы одно объявление использует let, в другом может использоваться let или var, и ошибка все равно произойдет, как показывают следующие два примера:

```js
var studentName = "Frank";
let studentName = "Suzy"; 
```
и:
```js
 let studentName = "Frank";
  var studentName = "Suzy";
```

В обоих случаях SyntaxError выдается для второго объявления. Иначе говоря, повторно объявить переменную можно только одним способом — использовать var во всех (двух или более) объявлениях.

Но почему это запрещено? Причина выдачи ошибки не является чисто технической, так как повторное объявление с var всегда было разрешено; очевидно, то же самое можно было сделать и для let. Скорее дело в социотехнике. Повторное объявление переменных рассматривается многими, включая участников комитета TC39, как вредная привычка, которая может привести к появлению ошибок в программах. Таким образом, когда в ES6 появилась поддержка let, было решено предотвратить повторное объявление при помощи ошибки.

>[!info] Примечание
>Конечно, это всего лишь стилистическое предпочтение, а не технический аргумент. Многие разработчики согласны с этой позицией, и, скорее всего, это отчасти объясняет, почему в TC39 было решено включить эту ошибку (а также поведение let в соответствии с const). Однако также можно было выдвинуть разумный аргумент о том, что сохранение согласованности с прецедентом var было более благоразумно и что такие принудительные меры лучше было оставить для инструментов, применяемых по усмотрению разработчика (например, синтаксических анализаторов). В приложении А мы рассмотрим вопрос о том, остается ли объявление var (и связанное с ним поведение — например, повторное объявление) полезным в современном `JS`.

Когда Компилятор обращается к Менеджеру области видимости с запросом об объявлении (был ли идентификатор объявлен ранее) и если в одном/обоих объявлениях используется let, происходит ошибка. Она должна подать разработчику четкий сигнал: «Не надо полагаться на некорректные переобъявления!»

#### Константы?

Ключевое слово const создает больше ограничений, чем let. Как и let, const не может повторяться с тем же идентификатором в одной области видимости. Однако в данном случае существует важная техническая причина, по которой запрещаются подобные повторные объявления (в отличие от ситуации с let, где повторное объявление запрещается в основном по стилистическим причинам).

Ключевое слово const требует, чтобы переменная была инициализирована, так что если опустить присваивание в объявлении, это приведет к ошибке SyntaxError:

```js
const empty; // SyntaxError
```

Переменной studentName нельзя присвоить новое значение, потому что она объявлена с ключевым словом const.

>[!info] Примечание
>При попытке повторного присваивания studentName выдается ошибка TypeError, а не SyntaxError. Это довольно важный нюанс, который, к сожалению, очень легко упустить из вида. Ошибки SyntaxError представляют сбои в программе, которые не позволяют начать выполнение. Ошибки TypeError представляют аномалии, возникающие в ходе выполнения программы. В приведенном фрагменте сообщение "Frank" выводится до обработки повторного присваивания studentName, при котором происходит ошибка.

Таким образом, если повторное присваивание для объявлений const невозможно, а объявления const всегда требуют присваивания, появляется четкая техническая причина, по которой для const должны быть запрещены повторные объявления: любое повторное объявление const также неизбежно станет повторным присваиванием const, а это запрещено! 

```js
const studentName = "Frank"; // очевидно, должно приводить к ошибке 
const studentName = "Suzy";
```

Так как повторное объявление для const должно быть запрещено (по техническим причинам), комитет TC39 в итоге решил, что «повторное объявление» для let также должно быть запрещено для обеспечения целостности. Трудно сказать, было ли это лучшим решением, но, по крайней мере, оно было продиктовано внутренней логикой.

#### Циклы

Из предыдущего обсуждения должно быть ясно, что `JS` на самом деле не хочет, чтобы мы «повторно объявляли» переменные в пределах области видимости. 

Возможно, это кажется банальной мерой предосторожности, пока вы не задумаетесь, что же означает повторное выполнение команд объявления в циклах. Пример:

```js
var keepGoing = true;
 while (keepGoing) {
  let value = Math.random(); 
  if (value > 0.5) { 
  keepGoing = false;
   }
 }
```

Переменная value многократно повторно объявляется в программе? Приводит ли это к выдаче ошибок? Нет

Все правила области видимости (включая повторное объявление переменных, созданных с let) применяются на уровне экземпляра области видимости. Иначе говоря, каждый раз, когда во время выполнения программа входит в область видимости, происходит сброс в исходное состояние.

Каждая итерация цикла имеет собственный новый экземпляр области видимости, и в каждом экземпляре области видимости value объявляется только один раз. Таким образом, попыток повторного объявления нет, а следовательно, нет и ошибки. Прежде чем рассматривать другие формы циклов, что произойдет, если заменить объявление value в приведенном фрагменте на var?

```js
var keepGoing = true;
 while (keepGoing) {
  var value = Math.random(); 
  if (value > 0.5) { 
  keepGoing = false;
   }
 }
```

Происходит ли повторное объявление переменной value — ведь мы знаем, что var его допускает? Нет. Так как переменная var не рассматривается как объявление с блоковой областью видимости (см. главу 6), она присоединяется к глобальной области видимости. Таким образом, здесь существует только одна переменная value в одной области видимости с keepGoing (глобальная область видимости в данном случае). Никакого повторного объявления здесь тоже нет! 

Чтобы разобраться во всем этом, можно запомнить, что ключевые слова var, let и const фактически удаляются из кода к тому моменту, когда он начинает выполняться. Всем этим занимается исключительно компилятор. 

Если вы мысленно удалите ключевые слова объявлений, а потом попытаетесь прочитать код, это поможет вам решить, где могут возникнуть (повторные) объявления (и могут ли вообще). 

Как насчет повторного объявления в других разновидностях циклов — например, циклов for?

```js
for (let i = 0; i < 3; i++) { 
let value = i * 10; 
console.log(`${ i }: ${ value }`); 
}
 // 0: 0 
 // 1: 10
 // 2: 20
```

Пример наглядно показывает, что на каждый экземпляр области видимости объявляется отдельный экземпляр value. Но как насчет i? Эта переменная объявляется повторно?

Чтобы ответить на этот вопрос, посмотрим, в какой области видимости находится переменная i. Может показаться, что она принадлежит внешней (в данном случае глобальной) области видимости, но это не так. Она находится в области видимости тела цикла for, как и value. Этот цикл можно неформально рассматривать в следующей эквивалентной форме:

```js
{ // фиктивная переменная для демонстрации 
let $$i = 0;
 for ( /* ничего */; $$i < 3; $$i++) {
  // настоящий цикл `i`!
   let i = $$i;
    let value = i * 10;
     console.log(`${ i }: ${ value }`);
      }
       // 0: 0
       // 1: 10
       // 2: 20 
}
```

Сейчас должно быть ясно: переменные i и value объявляются ровно один раз на экземпляр области видимости. Повторных объявлений здесь нет. 

Как насчет других форм циклов for?

```js
for (let index in students) { 
// нормально 
} 

for (let student of students) { 
// как и это 
}
```

Сказанное относится к циклам for..in и for..of: объявленная переменная рассматривается как находящаяся внутри тела цикла, а следовательно, обрабатывается на уровне итерации (т. е. на экземпляр области видимости). Снова никаких повторных объявлений.

Наверное, сейчас я уже напоминаю вам заезженную пластинку. Но давайте посмотрим, как const влияет на циклические конструкции. Пример:

```js
var keepGoing = true; 
while (keepGoing) {
 // новенькая константа!
  const value = Math.random();
   if (value > 0.5) { keepGoing = false; }
 }
```

Как и в варианте программы с let, приведенном выше, объявление const выполняется ровно один раз для каждой итерации цикла, поэтому оно защищено от проблем с повторным объявлением. Но когда речь заходит о циклах for, ситуация усложняется.

Циклы for..in и for..of вполне нормально работают с const:

```js
for (const index in students) { 
// нормально 
}

 for (const student of students) {
  // как и это 
} 
```

Но не общий цикл for:

```js
 for (const i = 0; i < 3; i++) {
  // после первой итерации происходит
   // сбой с ошибкой TypeError
 }
```

Что здесь не так? В этой конструкции можно было нормально использовать let, и ранее было сказано, что для области видимости каждой итерации создается новое значение i, потому вроде бы никакого повторного объявления здесь нет. 

Мысленно расширим этот цикл, как это делалось ранее:

```js
{ 
// фиктивная переменная для демонстрации 
const $$i = 0; 
for ( ; $$i < 3; $$i++) {
 // настоящий цикл `i`!
  const i = $$i;
   // .. 
   }
 }
```

Заметили проблему? Переменная i действительно просто создается за пределами цикла. С ней проблем нет. Проблема кроется в концептуальной переменной `$$i`, которая должна каждый раз инкрементироваться выражением `$$i++`. Это повторное присваивание (не повторное объявление), которое запрещено для констант.

Помните, что эта расширенная форма — не более чем концептуальная модель, которая помогает вам понять источник проблемы. Возможно, вас интересует, не может ли `JS` преобразовать const `$$i` = 0 в let `$ii` = 0, что позволило бы const работать с классическим циклом for? Да, такое возможно, но это создало бы потенциально неожиданные исключения в семантике цикла for. 

Например, возникло бы произвольное (и скорее всего, непонятное) неочевидное исключение: выражению i++ в заголовке цикла for было бы разрешено обходить жесткие ограничения с присваиванием const, тогда как другие повторные присваивания i внутри итерации цикла были бы запрещены (хотя иногда они бывают полезными). 

Наиболее прямолинейный ответ: const не может использоваться с классической формой for-цикла из-за необходимого повторного присваивания. Интересно, что без повторного присваивания такая конструкция действительна:

```js
var keepGoing = true;
 for (const i = 0; keepGoing; /* здесь ничего нет */ ) {
  keepGoing = (Math.random() > 0.5);
   // ..
 }
```

Этот фрагмент работает, но смысла в нем нет. Бессмысленно объявлять i в этой позиции с ключевым словом const, так как переменная в этой позиции объявляется именно для подсчета итераций. Просто используйте другую форму цикла (например, цикл while) или let!

### Неинициализированные переменные (TDZ)

С объявлениями var переменная поднимается в начало своей области видимости. Но она также автоматически инициализируется значением undefined, так что переменная может использоваться во всей области видимости. 

Но объявления let и const в этом отношении ведут себя не совсем одинаково. 

Пример:

```js
console.log(studentName); 
// ReferenceError 
let studentName = "Suzy";
```

В результате выполнения этой программы в первой строке выдается ошибка ReferenceError. В зависимости от вашей среды `JS` в сообщении об ошибке может быть сказано что-то вроде «не удается обратиться к studentName до инициализации».

> [! info] Примечание
> Приведенное сообщение об ошибке когда-то было намного более невразумительным или дезинформирующим. К счастью, некоторым участникам сообщества удалось добиться улучшения этого сообщения в движках `JS`, чтобы оно более точно сообщало вам, что произошло в программе!

Это сообщение достаточно четко сообщает, что не так: переменная studentName существует в строке 1, но она не была инициализиро-вана и поэтому использоваться еще не может. Попробуем сделать это:

```js
studentName = "Suzy"; // попробуем инициализировать!
 // ReferenceError 
 console.log(studentName);
  let studentName;
```

Увы. Все равно возникает ошибка ReferenceError, но на этот раз в первой строке, где мы пытаемся присвоить значение (т. е. инициализировать) так называемую неинициализированную переменную studentName. Как это понимать?!

Настоящий вопрос в том, как инициализировать неинициализированную переменную? Для let/const это можно сделать только присваиванием, совмещенным с командой объявления. Одного присваивания недостаточно! Пример:

```js
let studentName = "Suzy";
console.log(studentName); // Suzy
```

Здесь переменная studentName инициализируется (в данном случае "Suzy" вместо undefined) посредством разновидности объявления let, совмещенной с присваиванием.

Другое возможное решение:

```js
 let studentName; 
 // or:
// let studentName = undefined;
// .. 
studentName = "Suzy";
console.log(studentName); // Suzy
```

>[!info] Примечание
>Интересно! Вспомните: ранее мы говорили, что var studentName; — не то же самое, что var studentName = undefined;, но в данном случае с let они ведут себя одинаково. Различия сводятся к тому, что var studentName автоматически инициализируется в начале области видимости, а let studentName — нет.

Ранее мы уже несколько раз говорили, что компилятор в конечном итоге удаляет все объявления var/let/const и заменяет их командами регистрации соответствующих идентификаторов в начале каждой области видимости. 

Итак, если проанализировать, что здесь происходит, мы видим, что компилятор также добавляет команду в середине программы, в точке объявления переменной studentNamewas, для обеспечения автоматической инициализации этого объявления. Эта переменная не может использоваться в любой точке, предшествующей этой инициализации. Все сказанное относится к const в такой же степени, как let. 

Для обозначения этого периода от входа в область видимости до точки автоматической инициализации переменной в TC39 был предложен термин TDZ (Temporal Dead Zone).

TDZ — временное окно, в котором переменная существует, но все еще остается неинициализированной, и поэтому к ней невозможно обратиться никаким способом. Только команды, оставленные компилятором в точке исходного объявления, могут выполнить эту инициализацию. После этого момента TDZ завершается, а переменная может свободно использоваться в оставшейся части области видимости. 

Формально у var тоже есть область TDZ, но она имеет нулевую длину, а следовательно, остается ненаблюдаемой для наших программ! Наблюдаемые TDZ существуют только у let и const. 

Кстати говоря, определение «временное» (Temporal) в TDZ действительно относится ко времени, а не к позиции в коде. Пример: 

```js
askQuestion(); 
// ReferenceError 
let studentName = "Suzy";
 function askQuestion() {
  console.log(`${ studentName }, do you know?`); }
```

И хотя позиционно команда console.log(..) со ссылкой на studentName следует после объявления let studentName, по времени функция askQuestion() вызывается до обнаружения команды let, пока studentName все еще находится в TDZ! Отсюда и ошибка. 

Существует распространенное заблуждение, будто наличие TDZ говорит о том, что let и const не поднимаются. Это утверждение неточно или по крайней мере в какой-то степени ошибочно. Поднятие к ним определенно применяется. 

Реальное отличие заключается в том, что объявления let/const не инициализируются автоматически в начале области видимости так, как это происходит с var. Тогда возникает вопрос, является ли автоматическая инициализация частью поднятия или нет? Я думаю, что автоматическая регистрация переменной в начале области видимости (т. е. то, что я называю поднятием) и автоматическая инициализация в начале области видимости (значением undefined) являются разными операциями и их не следует сваливать вместе под общим термином «поднятие». 

Мы уже видели, что let и const не выполняют автоматической инициализации в начале области видимости. Но давайте докажем, что let и const выполняют поднятие (автоматическую регистрацию в начале области видимости) при помощи нашего знакомого — замещения (см. «Затенение», глава 3):

```js
var studentName = "Kyle"; 
{
 console.log(studentName);
 // ??? 
// .. 
let studentName = "Suzy";
 console.log(studentName); // Suzy
 }
```

Что произойдет с первой командой console.log(..)? Если let studentName не поднимается в начало области видимости, первый вызов console.log(..) должен вывести "Kyle", верно? Казалось бы, в этот момент есть только внешняя переменная studentName, поэтому именно к этой переменной должна обратиться и вывести команда console.log(..). 

Но вместо этого первая команда console.log(..) выдает ошибку TDZ, потому что переменная studentName из внутренней области видимости была поднята (автоматически зарегистрирована в начале области видимости). Однако на этот момент (еще!) не была выполнена автоматическая инициализация внутренней переменной studentName; на этот момент она остается неинициализированной, отсюда и нарушение TDZ! 

Подведем итог: ошибка TDZ возникает из-за того, что объявления let/const поднимаются в начало своих областей видимости, но, в отличие от var, они откладывают автоматическую инициализацию своих переменных до той точки последовательности выполнения, в которой появляется исходное объявление. Это временное окно, независимо от его длины, и образует область TDZ. 

Как избежать ошибок TDZ? 

Мой совет: всегда размещайте объявления let и const в начале области видимости. Уменьшите окно TDZ до нулевой (или почти нулевой) длины, и проблема исчезнет сама собой. 

Но почему тема TDZ вообще актуальна? Почему TC39 не потребует, чтобы let/const автоматически инициализировались так, как это делает var? Подождите немного, мы вернемся к ответам на вопросы «почему?» о TDZ в приложении А.

### После инициализации

При работе с переменными возникает гораздо больше нюансов, чем кажется на первый взгляд. Поднятие, (повторное) объявление и TDZ часто сбивают с толку разработчиков, особенно перешедших на `JS` с других языков. 

Прежде чем двигаться дальше, убедитесь в том, что в вашей внутренней модели хорошо проработаны эти аспекты областей видимости и переменных `JS`. 

Поднятие обычно описывается как реальный механизм движка `JS`, но в действительности это скорее метафора для описания различных аспектов обработки объявлений переменных `JS` в фазе компиляции. Но даже как метафора поднятие предоставляет полезную структуру для рассмотрения жизненного цикла переменной — когда она создается, когда становится доступной для использования и когда перестает существовать. 

Первичное и повторное объявление переменных обычно создают путаницу, когда они рассматриваются как операции времени выполнения. Но если рассматривать эти операции в контексте времени компиляции, все странности исчезают.

Ошибка TDZ (Temporal Dead Zone) раздражает. К счастью, ее можно элементарно избежать, если вы всегда будете размещать объявления let/const в начале любой области видимости. 

В этой главе вы начали успешно осваивать все хитросплетения области видимости переменной. В следующей главе будут представлены факторы, влияющие на наши решения о размещении объявлений в разных областях видимости, и прежде всего во вложенных блоках. 
Теперь вы должны достаточно хорошо понимать концепцию вложенности от глобальной области видимости вниз — так называемой цепочки областей видимости программы. 
Но просто знать, из какой области видимости происходит переменная, недостаточно. Если объявление переменной следует после первой команды в области видимости, как будут вести себя ссылки на этот идентификатор до его объявления? Что произойдет, если попытаться дважды объявить одну переменную в области видимости? 
Особая разновидность лексических областей видимости в `JS` богата нюансами в том, как и когда переменные начинают свое существование и становятся доступными для программы.
### Когда можно использовать переменную?
В какой момент переменная становится доступной для использования внутри своей области видимости? Казалось бы, ответ очевиден: после того, как переменная была объявлена/создана. Правильно? Не совсем. 
Пример:

```js
greeting(); // Hello!
function greeting() { console.log("Hello!"); }
```

Этот код работает нормально. Возможно, вы уже видели или даже писали нечто подобное. Но вы когда-нибудь задумывались над тем, как и почему он работает? А если конкретно, почему вы можете обратиться к идентификатору greeting из строки 1 (для получения и выполнения ссылки на функцию), хотя объявление функции greeting() происходит только в строке 4?

Вспомните: в главе 1 я говорил, что все идентификаторы регистрируются в соответствующих областях видимости во время компиляции. Более того, каждый идентификатор создается в начале той области видимости, которой он принадлежит, при каждом входе в эту область видимости. 

Ситуация, при которой переменная видима от начала своей вмещающей области видимости, несмотря на то что ее объявление может находиться ниже в области видимости, называется поднятием (hoisting).

Тем не менее одно лишь поднятие не дает полного ответа на вопрос. Идентификатор greeting виден от начала области видимости, но почему мы можем использовать функцию greeting() еще до того, как она была объявлена? 

Другими словами, как переменной greeting может быть присвоено значение (ссылка на функцию) с момента выполнения области видимости? Ответ кроется в специальной характеристике формальных объявлений function, называемой поднятием функций. Когда идентификатор объявления function регистрируется в начале своей области видимости, он дополнительно автоматически инициализируется ссылкой на эту функцию. Вот почему функция может вызываться во всей области видимости!

Одна ключевая подробность заключается в том, что и поднятие функции, и поднятие var-переменных связывают свои идентификаторы с ближайшей вмещающей областью видимости функции (а если ее нет — глобальной областью видимости), а не с блоковой областью видимости.

Объявления с let и const тоже поднимаются (см. часть о TDZ далее в этой главе). Но эти две формы объявлений связываются со своим вмещающим блоком, а не с вмещающей функцией, как в случае с объявлениями var и function. За дополнительной информацией обращайтесь к разделу «Области видимости и блоки» главы 6.

#### Поднятие: объявления и выражения

Поднятие функций применяется только к формальным объявлениям функций (а конкретно тех, которые располагаются вне блоков — см. раздел FiB главы 6), но не к присваиваниям функциональных выражений.

Пример:

```js
greeting(); // TypeError 
var greeting = function greeting() { console.log("Hello!"); };
```

В строке 1 (greeting();) происходит ошибка. И очень важно заметить разновидность этой ошибки. TypeError означает, что мы пытаемся что-то сделать с недопустимым значением. В зависимости от вашей среды `JS` в сообщении об ошибке может быть сказано что-то вроде «‘undefined’ не является функцией» или в более содержательном варианте — «‘greeting’ не является функцией». 

Обратите внимание: программа не выдает ошибку ReferenceError. `JS` не говорит, что найти идентификатор в области видимости не удалось. `JS` говорит, что идентификатор greeting был найден, но в данный момент он не содержит ссылки на функцию. Вызываться могут только функции, поэтому попытка вызова для любого значения, не являющегося функцией, приводит к ошибке. 

Но что же содержит greeting, если не ссылку на функцию? Кроме поднятия, переменные, объявленные с ключевым словом var, также автоматически инициализируются undefined в начале своей области видимости — это снова ближайшая вмещающая или глобальная область видимости. После инициализации они доступны для использования (присваивания, чтения и т. д.) во всей области видимости.

Таким образом, в первой строке greeting существует, но содержит только значение по умолчанию undefined. Только в строке 4 greeting будет присвоена ссылка на функцию.

Обратите особое внимание на это отличие. Объявление функции поднимается и инициализируется своим значением функции (еще раз: это называется поднятием функции). Переменная var тоже поднимается и автоматически инициализируется undefined. Все последующие присваивания функциональных выражений этой переменной не выполняются до того момента, когда это присваивание будет обработано во время выполнения. 

В обоих случаях идентификатор (имя) поднимается. Но связывание ссылки на функцию не обрабатывается во время инициализации (начало области видимости), если только идентификатор не был создан в формальном объявлении function

#### Поднятие переменной 

Рассмотрим еще один пример поднятия переменной:
```js
greeting = "Hello!";
console.log(greeting); // Hello!
 var greeting = "Howdy!"; 
```

И хотя идентификатор greeting не объявляется до строки 4, он доступен для присваивания уже в строке 1. Почему? У объяснения есть две необходимые составляющие:

- идентификатор поднимается; 
- он автоматически инициализируется значением undefined в начале области видимости.

>[!info] Примечание
>Вероятно, подобное использование поднятия переменных выглядит неестественно, и многие читатели с полным основанием предпочтут избегать его в своих программах. Но следует ли избегать всего под- нятия (включая поднятие функций)? Разные точки зрения на поднятие будут более подробно рассмотрены в приложении А.

### Поднятие: еще одна метафора

[[2. Лексическая видимость|Глава 2]]  была полна метафор (для демонстрации областей види- мости), но здесь мы сталкиваемся еще с одной — самим подняти- ем (hoisting). Не будем представлять поднятие как конкретный шаг, выполняемый движком JS на стадии выполнения, а рассмо- трим его как наглядное представление различных действий, вы- полняемых движком JS при подготовке программы до выполне- ния. 

Как правило, термин «поднятие» вызывает ассоциации с подня- тием тяжестей — т. е. любых идентификаторов до самого верха области видимости. В объяснениях часто утверждается, что дви- жок JS фактически перезаписывает программу перед выполнени- ем, так что в результате она выглядит примерно так:

```js
var greeting; // поднятое объявление
greeting = "Hello!"; // исходная строка 1
 console.log(greeting); // Hello! 
 greeting = "Howdy!"; // `var` исчезает! 
```

Поднятие (метафора) предполагает, что JS осуществляет пред- варительную обработку исходной программы и немного переупо- рядочивает его, так что все объявления перемещаются в начало соответствующих областей видимости перед выполнением. Более того, метафора поднятия утверждает, что все объявления функций полностью поднимаются в начало своих областей видимости. 
Пример:

```js
studentName = "Suzy";
greeting(); // Hello Suzy!
function greeting() { console.log(`Hello ${ studentName }!`); }
 var studentName;
```

«Правило» метафоры поднятия гласит, что объявления функций поднимаются первыми, а затем после всех функций немедленно поднимаются переменные. Таким образом, поднятие предполага- ет, что программа переупорядочивается движком JS так, чтобы она пришла к следующему виду:

```js
function greeting() { console.log(`Hello ${ studentName }!`); }
 var studentName;
  studentName = "Suzy"; 
  greeting(); // Hello Suzy
```

Метафора поднятия удобна. Она позволяет выполнить опережа- ющую предварительную обработку, необходимую для нахождения всех этих объявлений, зарытых где-то глубоко в областях види- мости, и каким-то волшебным образом поднять (переместить) их в начало; всю программу можно рассматривать так, словно она выполняется движком JS сверху вниз за один проход.

Однопроходная обработка определенно выглядит более понятно, чем двухфазная обработка, упоминавшаяся в главе 1. 

Поднятие как механизм переупорядочения кода — привлекатель- ное упрощенное представление, но оно неточно. Движок JS не осуществляет фактической перестановки кода. Оно не может по волшебству заглянуть вперед и найти объявления; точно опреде- лить их (а также все границы областей видимости в програм- ме) можно только одним способом — полным разбором кода. 

Угадайте, о каком разборе идет речь? О первой фазе двухфазной обработки! И никакие словесные ухищрения не обойдут этот факт. 

Таким образом, если метафора поднятия (в лучшем случае) не- точна, что же делать с этим термином? Я думаю, что он остается полезным — даже участники TC39 регулярно пользуются им! — но мы не можем утверждать, что он представляет фактическое пере- упорядочение исходного кода.

> [!info] Примечание
> Неправильные или неполные ментальные модели часто кажутся адек- ватными, потому что они в отдельных случаях приводят к правильным ответам. Но в долгосрочной перспективе вам будет труднее анализи- ровать и прогнозировать результаты, если ваши внутренние пред- ставления расходятся с тем, как реально работает движок JS.

Я считаю, что термин «поднятие» следует использовать для обо- значения выполняемой во время компиляции операции генери- рования команд для автоматической регистрации переменной в начале ее области видимости при каждом входе в эту область видимости. Это тонкий, но важный переход от поднятия как поведения вре- мени выполнения до его более подобающего места среди задач времени компиляции. 
### Повторное объявление?
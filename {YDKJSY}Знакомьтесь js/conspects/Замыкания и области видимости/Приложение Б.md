## Практика
### Введение

В этом приложении приводятся некоторые непростые и интересные упражнения, которые должны проверить и укрепить ваше понимание основных тем книги. Очень полезно попытаться выполнить упражнения самостоятельно — в настоящем редакторе кода — вместо того, чтобы переходить к решениям в конце. Не читерите!

Эти упражнения не имеют единственно правильного ответа. Ваш подход может незначительно (или значительно) отличаться от представленных решений, и это нормально. 

Не думайте, что эти упражнения оценивают ваши навыки программирования. Надеюсь, что вы закроете эту книгу, чувствуя большую уверенность в том, что справитесь с этими задачами, благодаря прочному фундаменту из полученных знаний. И это единственная цель этого приложения. Если вы довольны своим кодом, то им доволен и я!

#### Камешки и банки 

Помните рис. 2 из главы 2?
![400](https://storage.piter.com/upload/new_folder/978544611876/fig2.png)

В этом упражнении вам будет предложено написать любую программу, содержащую вложенные функции и блоковые области видимости, удовлетворяющую следующим ограничениям:
если раскрасить все области видимости (включая глобальную) в разные цвета, понадобится не менее 6 цветов. Обязательно добавьте комментарий, помечающий каждую область видимости своим цветом. ДОПОЛНИТЕЛЬНОЕ ЗАДАНИЕ: найдите все предполагаемые области видимости, которые могут присутствовать в вашей программе;
каждая область видимости содержит хотя бы один идентификатор;
содержит по крайней мере две функциональные области видимости и по крайней мере две блоковые области видимости; 
по крайней мере одна переменная из внешней области видимости должна замещаться переменной из вложенной области видимости (см. главу 3);
по крайней мере одна ссылка на переменную должна разрешаться в объявление переменной, находящейся не менее чем двумя уровнями выше в цепочке областей видимости. 

>[!info] Примечание
>Вы можете написать для этого упражнения мусорный код в стиле foo/ bar/baz, но рекомендую попробовать написать нетривиальный реальный код, который хотя бы пытается делать нечто разумное. 

### Замыкания (часть 1)  

Для начала потренируемся в использовании замыканий на примере некоторых математических операций, часто реализуемых на компьютерах: определения того, является ли значение простым (не делится нацело ни на какие числа, кроме 1 и самого себя), и генерирования списка простых множителей для заданного числа. 

Пример:

```js
isPrime(11);        // true
isPrime(12);        // false

factorize(11);      // [ 11 ]
factorize(12);      // [ 3, 2, 2 ] --> 3*2*2=12
```

Следующая реализация isPrime(..) адаптирована из библиотеки [^1]`Math.js`: 

```js
function isPrime(v) {
    if (v <= 3) {
        return v > 1;
    }
    if (v % 2 == 0 || v % 3 == 0) {
        return false;
    }
    var vSqrt = Math.sqrt(v);
    for (let i = 5; i <= vSqrt; i += 6) {
        if (v % i == 0 || v % (i + 2) == 0) {
            return false;
        }
    }
    return true;
}
```

Также приведу (довольно тривиальную) реализацию factorize(..) (не путайте с factorial(..) из главы 6): 

```js
function factorize(v) {
    if (!isPrime(v)) {
        let i = Math.floor(Math.sqrt(v));
        while (v % i != 0) {
            i--;
        }
        return [
            ...factorize(i),
            ...factorize(v / i)
        ];
    }
    return [v];
}
```

>[!info] Примечение
>Я называю эту реализацию тривиальной, потому что она не оптимизирована по производительности. Она является бинарно-рекурсивной (т. е. непригодной для оптимизации хвостовых вызовов), а также создает множество промежуточных копий массива. Кроме того, найденные множители никак не упорядочиваются. Есть множество других алгоритмов для этой задачи, но для нашего упражнения я хотел использовать нечто короткое и достаточно понятное.

Если вы вызовете isPrime(4327) несколько раз в программе, то увидите, что каждый раз выполняются все десятки шагов сравнения/вычислений. Если присмотреться к функции factorize(..), вы заметите, что она многократно вызывает isPrime(..) при вычислении списка множителей. Существует достаточно высокая вероятность того, что многие из этих вызовов повторяются. Слишком много работы пропадает даром! 

Первая часть упражнения: воспользуйтесь замыканием для реализации кэша, в котором будут сохраняться результаты isPrime(..), чтобы признак простоты заданного числа (true или false) вычислялся только один раз. Подсказка: подобное кэширование уже было продемонстрировано в главе 6 на примере factorial(..). 

Также можно заметить, что функция factorize(..) реализована с рекурсией, т. е. многократно вызывает саму себя. Это снова означает, что мы с большой вероятностью столкнемся с множеством повторных вызовов для вычисления простых множителей одного и того же числа. Во второй части упражнения вам предстоит реализовать тот же механизм кэширования из замыкания для factorize(..). 

Используйте разные замыкания для кэширования isPrime(..) и factorize(..), вместо того чтобы размещать их в одной области видимости. 

Попробуйте выполнить упражнение самостоятельно, а затем сверьтесь с предлагаемым решением в конце приложения. 

####  Несколько слов о памяти

Хочу сказать несколько слов о кэшировании из замыканий и об его последствиях для быстродействия приложения. 

Нетрудно убедиться, что сохранение результатов повторяющихся вызовов повышает скорость вычислений (в отдельных случаях очень значительно). Но такое использование замыканий сопряжено с компромиссом, о котором вы должны очень хорошо знать. 

И этот компромисс связан с использованием памяти. Фактически мы наращиваем объем нашего кэша (в памяти) неограниченно. Если функция будет вызвана много миллионов раз с уникальными входными данными, это приведет к серьезным затратам памяти. Затраты определенно могут быть оправданы, но только если вы ожидаете, что входные данные будут с большой вероятностью повторяться. Если практически каждый вызов будет иметь уникальные входные данные, а кэш почти никогда не будет использоваться, применять кэширование не стоит. 

Также, возможно, стоит воспользоваться более сложным методом кэширования — например, кэшем LRU (Least Recently Used) с ограниченным размером; при заполнении кэша LRU из него вытесняются элементы с наиболее давним использованием. 

Недостаток такого решения в том, что кэш LRU достаточно нетривиален сам по себе. Вам придется использовать высокооптимизированную реализацию LRU и четко представлять себе все плюсы и минусы, с которыми вы столкнетесь. 

### Замыкания (часть 2) 

В этом упражнении мы снова потренируемся в использовании замыканий. Для этого будет определена вспомогательная функция toggle(..), которая возвращает функцию для перебора значений. 

Вы передаете toggle(..) одно или несколько значений (аргументов), и получаете обратно функцию. Возвращенная функция поочередно возвращает значения из своего списка при повторных вызовах. 

```js
function toggle(/* .. */) {
    // ..
}

var hello = toggle("hello");
var onOff = toggle("on","off");
var speed = toggle("slow","medium","fast");

hello();      // "hello"
hello();      // "hello"

onOff();      // "on"
onOff();      // "off"
onOff();      // "on"

speed();      // "slow"
speed();      // "medium"
speed();      // "fast"
speed();      // "slow"
```

Граничный случай, при котором toggle(..) не передается ни одно значение, не особо важен; в этом случае возвращенный экземпляр функции может просто всегда возвращать undefined. Попробуйте выполнить упражнение самостоятельно, а затем сверьтесь с предлагаемым решением в конце приложения. 

### Замыкания (часть 3) 

В третьем и последнем упражнении, посвященном замыканиям, будет реализован простейший калькулятор. Функция calculator() создаст экземпляр калькулятора, поддерживающего свое состояние, в форме функции (calc(..) в следующем листинге): 

```js
function calculator() {
    // ..
}

var calc = calculator();
```

При каждом вызове calc(..) передается один символ, представляющий нажатие кнопки на калькуляторе. Чтобы не усложнять задачу, ограничим наш калькулятор вводом только цифр (0-9), арифметических операций (`+`, `-`, `*`, `/`) и знака = для вычисления результата. Операции обрабатываются строго в порядке ввода; не поддерживаются ни группировка (), ни приоритеты операторов.

Ввод дробных чисел не поддерживается, но они могут появляться в результате выполнения операции деления. Ввод отрицательных чисел не поддерживается, но они могут появиться в результате выполнения операции вычитания. Таким образом, любое отрицательное или вещественное число можно сгенерировать, выполнив сначала операцию для его вычисления. После этого можно продолжить вычисления с этим значением. 

Значение, возвращаемое при вызовах calc(..), должно моделировать показания на дисплее реального калькулятора — либо воспроизводить только что нажатую клавишу, либо вычислять результат при нажатии =.
Пример: 

```js
calc("4");     // 4
calc("+");     // +
calc("7");     // 7
calc("3");     // 3
calc("-");     // -
calc("2");     // 2
calc("=");     // 75
calc("*");     // *
calc("4");     // 4
calc("=");     // 300
calc("5");     // 5
calc("-");     // -
calc("5");     // 5
calc("=");     // 0
```

Так как пользоваться таким калькулятором неудобно, определяется вспомогательная функция useCalc(..), которая последовательно передает калькулятору символы из строки и каждый раз вычисляет выводимое значение: 

```js
function useCalc(calc,keys) {
    return [...keys].reduce(
        function showDisplay(display,key){
            var ret = String( calc(key) );
            return (
                display +
                (
                  (ret != "" && key == "=") ?
                      "=" :
                      ""
                ) +
                ret
            );
        },
        ""
    );
}

useCalc(calc,"4+3=");           // 4+3=7
useCalc(calc,"+9=");            // +9=16
useCalc(calc,"*8=");            // *5=128
useCalc(calc,"7*2*3=");         // 7*2*3=42
useCalc(calc,"1/0=");           // 1/0=ERR
useCalc(calc,"+3=");            // +3=ERR
useCalc(calc,"51=");            // 51
```

В самом разумном сценарии использования useCalc(..) последним вводимым символом всегда должен быть знак =. 

Форматирование выводимых результатов иногда требует специальной обработки. Я представлю функцию formatTotal(..), которая должна использоваться вашим калькулятором каждый раз, когда он должен вывести текущий вычисленный результат (после ввода =): 

```js
function formatTotal(display) {
    if (Number.isFinite(display)) {
        // constrain display to max 11 chars
        let maxDigits = 11;
        // reserve space for "e+" notation?
        if (Math.abs(display) > 99999999999) {
            maxDigits -= 6;
        }
        // reserve space for "-"?
        if (display < 0) {
            maxDigits--;
        }

        // whole number?
        if (Number.isInteger(display)) {
            display = display
                .toPrecision(maxDigits)
                .replace(/\.0+$/,"");
        }
        // decimal
        else {
            // reserve space for "."
            maxDigits--;
            // reserve space for leading "0"?
            if (
                Math.abs(display) >= 0 &&
                Math.abs(display) < 1
            ) {
                maxDigits--;
            }
            display = display
                .toPrecision(maxDigits)
                .replace(/0+$/,"");
        }
    }
    else {
        display = "ERR";
    }
    return display;
}
```

Не отвлекайтесь на то, как работает formatTotal(..). Большая часть ее логики сводится к ограничению вывода калькулятора 11 символами (даже для отрицательных чисел), повторяющихся точек и даже экспоненциальной записи «e+», если она требуется. 

И постарайтесь не увязнуть в болоте вокруг специфического поведения калькулятора. Сосредоточьтесь на памяти замыкания.

Попробуйте выполнить упражнение самостоятельно, а затем сверьтесь с предлагаемым решением в конце приложения. 

### Модули

В этом упражнении калькулятор из упражнения «Замыкания» (часть 3) преобразуется в модуль. 

Мы не будем добавлять в калькулятор никакую дополнительную функциональность, только изменим интерфейс. Вместо вызова одиночной функции calc(..) мы будем вызывать конкретные методы открытого API для каждого нажатия клавиши на калькуляторе. Результаты остаются теми же. 

Этот модуль должен быть выражен в виде фабричной функции классического модуля с именем calculator() вместо одиночного экземпляра IIFE, чтобы при желании можно было создать несколько экземпляров калькулятора. 

Открытый API должен включать следующие методы:

number(..) (ввод: нажатый символ/цифра) 
plus()
minus()
mult()
div()
eq()

Сценарий использования выглядит примерно так: 

```js
var calc = calculator();

calc.number("4");     // 4
calc.plus();          // +
calc.number("7");     // 7
calc.number("3");     // 3
calc.minus();         // -
calc.number("2");     // 2
calc.eq();            // 75
```

Функция formatTotal(..) остается такой же, как в предыдущем упражнении. Однако вспомогательную функцию useCalc(..) необходимо отрегулировать для работы с API модуля: 

```js
function useCalc(calc,keys) {
    var keyMappings = {
        "+": "plus",
        "-": "minus",
        "*": "mult",
        "/": "div",
        "=": "eq"
    };

    return [...keys].reduce(
        function showDisplay(display,key){
            var fn = keyMappings[key] || "number";
            var ret = String( calc[fn](key) );
            return (
                display +
                (
                  (ret != "" && key == "=") ?
                      "=" :
                      ""
                ) +
                ret
            );
        },
        ""
    );
}

useCalc(calc,"4+3=");           // 4+3=7
useCalc(calc,"+9=");            // +9=16
useCalc(calc,"*8=");            // *5=128
useCalc(calc,"7*2*3=");         // 7*2*3=42
useCalc(calc,"1/0=");           // 1/0=ERR
useCalc(calc,"+3=");            // +3=ERR
useCalc(calc,"51=");            // 51
```

Попробуйте выполнить упражнение самостоятельно, а затем сверьтесь с предлагаемым решением в конце приложения. 

Работая над этим упражнением, также выделите немного времени на анализ достоинств и недостатков представления калькулятора в формате модуля в отличие от подхода с функцией/замыканием из предыдущего упражнения. 

ДОПОЛНИТЕЛЬНОЕ ЗАДАНИЕ: объясните свой ход мыслей в нескольких предложениях. 

ДОПОЛНИТЕЛЬНОЕ ЗАДАНИЕ 2: попробуйте преобразовать свой модуль к другому формату модулей, включая UMD, CommonJS и ESM (ES Modules). 

### Предлагаемые решения 

Надеюсь, вы попробовали самостоятельно выполнить упражнения, прежде чем переходить к ответам. Не мухлевать! 

Помните, что каждое предлагаемое решение — всего лишь один из многих возможных вариантов решения задач. Ответы не являются единственно правильными, а всего лишь демонстрируют разумный подход к решению. 

Главное, что вы можете сделать с предлагаемыми решениями, — сравнить их со своим кодом и проанализировать, почему мы приняли похожие или разные решения. Не увлекайтесь мало значительными подробностями; постарайтесь сосредоточиться на главной теме. 

Предлагаемое решение: «Камешки и банки»

Решение упражнения «Камешки и банки» может выглядеть так: 

```js
// RED(1)
const howMany = 100;

// Sieve of Eratosthenes
function findPrimes(howMany) {
    // BLUE(2)
    var sieve = Array(howMany).fill(true);
    var max = Math.sqrt(howMany);

    for (let i = 2; i < max; i++) {
        // GREEN(3)
        if (sieve[i]) {
            // ORANGE(4)
            let j = Math.pow(i,2);
            for (let k = j; k < howMany; k += i) {
                // PURPLE(5)
                sieve[k] = false;
            }
        }
    }

    return sieve
        .map(function getPrime(flag,prime){
            // PINK(6)
            if (flag) return prime;
            return flag;
        })
        .filter(function onlyPrimes(v){
            // YELLOW(7)
            return !!v;
        })
        .slice(1);
}

findPrimes(howMany);
// [
//    2, 3, 5, 7, 11, 13, 17,
//    19, 23, 29, 31, 37, 41,
//    43, 47, 53, 59, 61, 67,
//    71, 73, 79, 83, 89, 97
// ]
```

#### Предлагаемое решение: «Замыкания» (часть 1) 

Решение упражнения «Замыкания» (часть 1) для функций isPrime(..) и factorize(..) может выглядеть так: 

```js
var isPrime = (function isPrime(v){
    var primes = {};

    return function isPrime(v) {
        if (v in primes) {
            return primes[v];
        }
        if (v <= 3) {
            return (primes[v] = v > 1);
        }
        if (v % 2 == 0 || v % 3 == 0) {
            return (primes[v] = false);
        }
        let vSqrt = Math.sqrt(v);
        for (let i = 5; i <= vSqrt; i += 6) {
            if (v % i == 0 || v % (i + 2) == 0) {
                return (primes[v] = false);
            }
        }
        return (primes[v] = true);
    };
})();

var factorize = (function factorize(v){
    var factors = {};

    return function findFactors(v) {
        if (v in factors) {
            return factors[v];
        }
        if (!isPrime(v)) {
            let i = Math.floor(Math.sqrt(v));
            while (v % i != 0) {
                i--;
            }
            return (factors[v] = [
                ...findFactors(i),
                ...findFactors(v / i)
            ]);
        }
        return (factors[v] = [v]);
    };
})();
```

Общая последовательность действий, которые я использовал для каждой функции:
1. Упаковать IIFE для определения области видимости, в которой будет находиться переменная с кэшем.
2. В используемом вызове сначала проверить кэш, и если результат уже известен — вернуть его. 
3. В каждом месте, где в исходной версии располагалось ключевое слово return, присвоить значение элементу кэша ипросто вернуть результаты операции присваивания — это трюк для экономии памяти, который в книге используется прежде всего для краткости. 

Я также переименовал внутреннюю функцию factorize(..) в findFactors(..). Технически это не является необходимым, но помогает более четко выразить, какую функцию вызывают рекурсивные вызовы.

#### Предлагаемое решение: «Замыкания» (часть 2)

Решение упражнения «Замыкания» (часть 2) для функции toggle(..) может выглядеть так:

```js
function toggle(...vals) {
    var unset = {};
    var cur = unset;

    return function next(){
        // save previous value back at
        // the end of the list
        if (cur != unset) {
            vals.push(cur);
        }
        cur = vals.shift();
        return cur;
    };
}

var hello = toggle("hello");
var onOff = toggle("on","off");
var speed = toggle("slow","medium","fast");

hello();      // "hello"
hello();      // "hello"

onOff();      // "on"
onOff();      // "off"
onOff();      // "on"

speed();      // "slow"
speed();      // "medium"
speed();      // "fast"
speed();      // "slow"
```


#### Предлагаемое решение: «Замыкания» (часть 3) 

Решение упражнения «Замыкания» (часть 3) для функции calculator(..) может выглядеть так: 

```js
// from earlier:
//
// function useCalc(..) { .. }
// function formatTotal(..) { .. }

function calculator() {
    var currentTotal = 0;
    var currentVal = "";
    var currentOper = "=";

    return pressKey;

    // ********************

    function pressKey(key){
        // number key?
        if (/\d/.test(key)) {
            currentVal += key;
            return key;
        }
        // operator key?
        else if (/[+*/-]/.test(key)) {
            // multiple operations in a series?
            if (
                currentOper != "=" &&
                currentVal != ""
            ) {
                // implied '=' keypress
                pressKey("=");
            }
            else if (currentVal != "") {
                currentTotal = Number(currentVal);
            }
            currentOper = key;
            currentVal = "";
            return key;
        }
        // = key?
        else if (
            key == "=" &&
            currentOper != "="
        ) {
            currentTotal = op(
                currentTotal,
                currentOper,
                Number(currentVal)
            );
            currentOper = "=";
            currentVal = "";
            return formatTotal(currentTotal);
        }
        return "";
    };

    function op(val1,oper,val2) {
        var ops = {
            // NOTE: using arrow functions
            // only for brevity in the book
            "+": (v1,v2) => v1 + v2,
            "-": (v1,v2) => v1 v2,
            "*": (v1,v2) => v1 * v2,
            "/": (v1,v2) => v1 / v2
        };
        return ops[oper](val1,val2);
    }
}

var calc = calculator();

useCalc(calc,"4+3=");           // 4+3=7
useCalc(calc,"+9=");            // +9=16
useCalc(calc,"*8=");            // *5=128
useCalc(calc,"7*2*3=");         // 7*2*3=42
useCalc(calc,"1/0=");           // 1/0=ERR
useCalc(calc,"+3=");            // +3=ERR
useCalc(calc,"51=");            // 51
```

>[!info] Примечание
>Помните: это упражнение посвящено замыканиям. Основное внимание в нем должно уделяться не фактической механике работы калькулятора, а правильному сохранению состояния калькулятора между вызовами. 

#### Предлагаемое решение: «Модули» 

Решение упражнения «Модули» для функции calculator(..) может выглядеть так: 

```js
// from earlier:
//
// function useCalc(..) { .. }
// function formatTotal(..) { .. }

function calculator() {
    var currentTotal = 0;
    var currentVal = "";
    var currentOper = "=";

    var publicAPI = {
        number,
        eq,
        plus() { return operator("+"); },
        minus() { return operator("-"); },
        mult() { return operator("*"); },
        div() { return operator("/"); }
    };

    return publicAPI;

    // ********************

    function number(key) {
        // number key?
        if (/\d/.test(key)) {
            currentVal += key;
            return key;
        }
    }

    function eq() {
        // = key?
        if (currentOper != "=") {
            currentTotal = op(
                currentTotal,
                currentOper,
                Number(currentVal)
            );
            currentOper = "=";
            currentVal = "";
            return formatTotal(currentTotal);
        }
        return "";
    }

    function operator(key) {
        // multiple operations in a series?
        if (
            currentOper != "=" &&
            currentVal != ""
        ) {
            // implied '=' keypress
            eq();
        }
        else if (currentVal != "") {
            currentTotal = Number(currentVal);
        }
        currentOper = key;
        currentVal = "";
        return key;
    }

    function op(val1,oper,val2) {
        var ops = {
            // NOTE: using arrow functions
            // only for brevity in the book
            "+": (v1,v2) => v1 + v2,
            "-": (v1,v2) => v1 v2,
            "*": (v1,v2) => v1 * v2,
            "/": (v1,v2) => v1 / v2
        };
        return ops[oper](val1,val2);
    }
}

var calc = calculator();

useCalc(calc,"4+3=");           // 4+3=7
useCalc(calc,"+9=");            // +9=16
useCalc(calc,"*8=");            // *5=128
useCalc(calc,"7*2*3=");         // 7*2*3=42
useCalc(calc,"1/0=");           // 1/0=ERR
useCalc(calc,"+3=");            // +3=ERR
useCalc(calc,"51=");            // 51
```

И на этом книга завершена — поздравляю вас с достижением! Увидимся снова!

[^1]: Math.js: isPrime(..), https://github.com/josdejong/mathjs/blob/develop/src/ function/utils/isPrime.js, 3 марта 2020 года

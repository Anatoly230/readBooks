### А Дальнейшее изучение

В этом приложении рассматриваются некоторые нюансы и граничные случаи, связанные со многими темами, рассмотренными в основном тексте книги. Это необязательный вспомогательный материал. 

Некоторые люди считают, что слишком глубокое погружение в граничные случаи и разнообразные мнения только создают лишний шум и отвлекают — по их мнению, разработчику лучше придерживаться исхоженных путей. Мой подход критиковали как непрактичный и не способствующий эффективной работе. Я понимаю эту точку зрения, хотя и не разделяю ее. 

Я считаю, что лучше вооружиться знаниями о том, как работают те или иные механизмы, чем пропускать все подробности, руководствуясь догадками и недостатком любознательности. Рано или поздно вы столкнетесь с ситуациями, в которых что-то возникает из той части, которую вы еще не изучали. Дорога не всегда бывает ровной. Так почему бы не подготовиться к неизбежным ухабам и рытвинам на пересеченной местности?

Здесь мое мнение выражено сильнее, чем в основной части книги; помните об этом, когда будете обдумывать и запоминать эту информацию. Приложение немного напоминает подборку постов в микроблоге, посвященных отдельным темам книги. Обсуждение будет длинным и непростым, так что не жалейте времени и не пролистывайте сложные моменты.

### Предполагаемые области видимости 

Области видимости иногда создаются в неочевидных местах. На практике эти предполагаемые области видимости редко влияют на поведение вашей программы, и все же вам будет полезно знать об их существовании. Обращайте внимание на следующие неочевидные области видимости: 
область видимости параметров; 
область видимости имен функций.

#### Область видимости параметров 
Из метафоры диалога в [[2. Лексическая видимость#Камешки, банки, рамки… Ну и ну!|главе 2]] может создаться впечатление, что параметры функций по сути не отличаются от локально объявленных переменных в области видимости функции. Но это не всегда так.
Пример:

```js
// outer/global scope: RED(1)

function getStudentName(studentID) {
    // function scope: BLUE(2)

    // ..
}
```

Здесь `studentID` считается простым параметром, поэтому он ведет себя как элемент *области видимости функции* СИНИЙ (2). Но если преобразовать его в сложный параметр, технически это перестанет быть так. К сложным формам параметров относятся параметры со значениями по умолчанию, переменные списки параметров (с использованием ...) и деструктурированные параметры
Пример:

```js
// outer/global scope: RED(1)

function getStudentName(/*BLUE(2)*/ studentID = 0) {
    // function scope: GREEN(3)

    // ..
}
```

Здесь список параметров фактически превращается в отдельную область видимости, а область видимости функции становится вложенной в эту область видимости. 

Почему? Что от этого изменится? Сложные формы параметров создают различные граничные случаи, поэтому список параметров превращается в отдельную область видимости для повышения эффективности работы с ними. 
Пример:

```js
function getStudentName(studentID = maxID, maxID) {
    // ..
}
```

Будем считать, что операции выполняются слева направо. Значение по умолчанию `=maxID` для параметра `studentID` требует, чтобы переменная `maxID` уже существовала (и была инициализирована). Код выдает ошибку `TDZ` ([[5. (Не такой уж) тайный жизненный цикл переменных#Неинициализированные переменные (TDZ)|глава 5]]). Причина в том, что переменная `maxID` объявлена в *области видимости параметро*в, но еще не была инициализирована из-за порядка параметров. Если переключиться на противоположный порядок параметров, ошибка `TDZ` не возникнет: 

```js
function getStudentName(maxID,studentID = maxID) {
    // ..
}
```

Ситуация становится еще сложнее, если ввести функциональное выражение в позиции параметра по умолчанию, где оно может создать собственное замыкание ([[7. Использование замыканий|глава 7]]) на параметрах предполагаемой области видимости: 

```js
function whatsTheDealHere(id,defaultID = () => id) {
    id = 5;
    console.log( defaultID() );
}

whatsTheDealHere(3);
// 5
```

Возможно, этот фрагмент имеет смысл, потому что стрелочная функция `defaultID()` замыкается на параметре/переменной `id`, которому затем присваивается значение `5`. Но давайте добавим замещающее определение `id` в *области видимости функции*: 

```js
function whatsTheDealHere(id,defaultID = () => id) {
    var id = 5;
    console.log( defaultID() );
}

whatsTheDealHere(3);
// 3
```

Надо же! Объявление `var id = 5` замещает параметр `id`, но замыкание функции `defaultID()` распространяется на параметр, а не на замещающую переменную в теле функции. Это доказывает, что список параметров заключается в отдельную область видимости. Впрочем, и это еще не все! 

```js
function whatsTheDealHere(id,defaultID = () => id) {
    var id;

    console.log(`local variable 'id': ${ id }`);
    console.log(
        `parameter 'id' (closure): ${ defaultID() }`
    );

    console.log("reassigning 'id' to 5");
    id = 5;

    console.log(`local variable 'id': ${ id }`);
    console.log(
        `parameter 'id' (closure): ${ defaultID() }`
    );
}

whatsTheDealHere(3);
// local variable 'id': 3   <--Huh!? Weird!
// parameter 'id' (closure): 3
// reassigning 'id' to 5
// local variable 'id': 5
// parameter 'id' (closure): 3
```

Странно выглядит первое консольное сообщение. В этот момент замещающая локальная переменная `id` только что была объявлена конструкцией `var id`, которая, как было сказано в [[5. (Не такой уж) тайный жизненный цикл переменных|главе 5]], обычно автоматически инициализируется `undefined` в начале области видимости. Почему не выводится `undefined`? 

В этом конкретном граничном случае (ради совместимости с унаследованным кодом) `JS` автоматически инициализирует `id` не значением `undefined`, а значением параметра `id` (3)!

Хотя в данный момент кажется, что два идентификатора `id` представляют одну переменную, на самом деле это разные переменные (находящиеся в разных *областях видимости*). 

Присваивание `id = 5` наглядно доказывает это расхождение; параметр `id` остается равным `3`, а локальная переменная становится равной ``return id``. 

Чтобы не столкнуться с этими странностями, я рекомендую:
никогда не замещать параметры локальными переменными;
избегать использования функции с параметрами по умолчанию, которая создает замыкание по своим параметрам. 

По крайней мере, теперь вы знаете о том, что список параметров находится в отдельной области видимости, если какие-либо из параметров не являются простыми, и сможете проявить необходимую осторожность. Область

### Область видимости имени функции

В разделе «Область видимости имени функции» [[3. Цепочка областей видимости#Область видимости имени функции|главы 3]] я упоминал о том, что имя функционального выражения добавляется в собственную область видимости функции. Вспомните: 

```js
var askQuestion = function ofTheTeacher(){ // .. }; 
```

Правда, `ofTheTeacher` не добавляется в окружающую область видимости (где объявляется `askQuestion`), но она также не просто добавляется в *область видимости функции*, как можно было бы ожидать. Это еще один странный граничный случай предполагаемой области видимости. 

Идентификатор `name` функционального выражения принадлежит собственной предполагаемой области видимости, вложенной между внешней окружающей областью видимости и основной областью видимости внутренней функции. 

Если бы переменная `ofTheTeacher` находилась в области видимости функции, можно было бы ожидать, что здесь произойдет ошибка:

```js
var askQuestion = function ofTheTeacher(){ 
// почему не происходит ошибка повторяющегося объявления? 
let ofTheTeacher = "Confused, yet?"; }; 
```

Форма объявления `let` не допускает повторного объявления (см. [[5. (Не такой уж) тайный жизненный цикл переменных#Неинициализированные переменные (TDZ)|главу 5]]). Однако это абсолютно законное *затенение*, а не повторное объявление, потому что два идентификатора `ofTheTeacher` находятся в разных областях видимости. Вряд ли вы когда-нибудь окажетесь в ситуации, в которой важна область видимости идентификатора имени функции. Но будет полезно знать, как работают эти механизмы. Чтобы не попасть в ловушку, никогда не замещайте идентификаторы имен функций. 

### Анонимные и именованные функции

Как обсуждалось в [[3. Цепочка областей видимости|главе 3]], функции могут записываться как в именованной, так и в *анонимной* форме. *Анонимная* форма встречается гораздо чаще, но так ли это хорошо? 

При выборе имен для ваших функций необходимо учитывать следующие факторы:
- автоматическое определение имен неполно; 
- лексические имена допускают ссылки на самих себя; 
- имена должны быть полезными описаниями;
- стрелочные функции не имеют лексических имен;
- `IIFE` также нужны имена.

#### Явные или автоматически определяемые имена?

У каждой функции в вашей программе есть определенная цель. Если у функции нет цели, удалите ее, потому что она только попусту занимает место. Если цель есть, то для нее можно подобрать имя.

Вероятно, до этого момента большинство читателей соглашается со мной. Но означает ли это, что имя всегда следует включать в код? И вот здесь я предвижу немало удивленных взглядов. Я без малейших колебаний отвечу: да! 

Прежде всего, `anonymous` в трассировке стека совершенно не упрощает процесс отладки: 

```js
btn.addEventListener("click",function(){
    setTimeout(function(){
        ["a",42].map(function(v){
            console.log(v.toUpperCase());
        });
    },100);
});
// Uncaught TypeError: v.toUpperCase is not a function
//     at myProgram.js:4
//     at Array.map (<anonymous>)
//     at myProgram.js:3
```

Сравните с результатом, который будет получен при назначении функциям имен:

```js
btn.addEventListener("click",function onClick(){
    setTimeout(function waitAMoment(){
        ["a",42].map(function allUpper(v){
            console.log(v.toUpperCase());
        });
    },100);
});
// Uncaught TypeError: v.toUpperCase is not a function
//     at allUpper (myProgram.js:4)
//     at Array.map (<anonymous>)
//     at waitAMoment (myProgram.js:3)
```

Имена `waitAMoment` и `allUpper` присутствуют в выходных данных, благодаря чему трассировка стека предоставляет более содержательную информацию/контекст для отладки. Если вы присвоите разумные имена всем своим функциям, это упростит отладку программы.

>[!info] Примечание
>Неприятная строка `<anonymous>`, которая все еще присутствует в результатах, относится к тому факту, что реализация `Array.map(..)` отсутствует в нашей программе, т к. встроена в движок `JS`. Дело не в какой-то путанице, возникшей в программе из-за сокращений для удобочитаемости. 

Кстати, давайте убедимся в том, что мы одинаково понимаем смысл термина «именованная функция»: 

```js
function thisIsNamed() {
    // ..
}

ajax("some.url",function thisIsAlsoNamed(){
   // ..
});

var notNamed = function(){
    // ..
};

makeRequest({
    data: 42,
    cb /* also not a name */: function(){
        // ..
    }
});

var stillNotNamed = function butThisIs(){
    // ..
};
```

«Постойте-ка! — скажете вы. — Некоторые из этих функций являются именованными, верно?»

```js
var notNamed = function(){
    // ..
};

var config = {
    cb: function(){
        // ..
    }
};

notNamed.name;
// notNamed

config.cb.name;
// cb
```

Такие имена называются автоматически определяемыми. В автоматически определяемых именах нет ничего плохого, но они не решают обсуждаемой проблемы. Анонимные

### Отсутствующие имена?

Да, автоматически определяемые имена могут присутствовать в трассировке, что определенно лучше `anonymous`. Но…

```js
function ajax(url,cb) {
 console.log(cb.name); 
 } 
 ajax("some.url",function(){ // .. }); // "" 
```

Какая неприятность... Анонимные функциональные выражения, передаваемые как обратные вызовы, не могут получить автоматически определяемое имя, поэтому `cb.name` содержит только пустую строку `""`. Подавляющее большинство всех функциональных выражений, особенно анонимных, используется в аргументах обратных вызовов; имена им не присваиваются. Таким образом, возможности автоматического определения имен в лучшем случае ограниченны.

И автоматическое определение дает сбой не только с обратными вызовами:

```js
var config = {};

config.cb = function(){
    // ..
};

config.cb.name;
// ""

var [ noName ] = [ function(){} ];
noName.name
// ""
```

Автоматическое определение имен также не справляется с любым присваиванием функционального выражения, которое не является простым присваиванием. Иначе говоря, если вы не будете действовать осторожно и сознательно, почти все анонимные функциональные выражения в вашей программе не будут иметь никаких имен. 

Автоматического определения имен попросту недостаточно. 

И даже если функциональное выражение получит автоматически определяемое имя, оно все еще не считается полноценной именованной функцией. 

### Кто я?

Без лексического идентификатора/имени функция не имеет внутренней возможности сослаться на саму себя. Автоссылки важны для таких механизмов, как *рекурсия* и *обработка событий*: 

```js
// broken
runOperation(function(num){
    if (num <= 1) return 1;
    return num * oopsNoNameToCall(num 1);
});

// also broken
btn.addEventListener("click",function(){
   console.log("should only respond to one click!");
   btn.removeEventListener("click",oopsNoNameHere);
});
```

Исключение *лексического имени* из обратного вызова усложняет надежные *автоссылки* на функцию. Вы можете объявить в окружающей *области видимости* переменную, которая содержит ссылку на функцию, но эта переменная находится под контролем окружающей области видимости — ей можно присвоить новое значение и т. д., и поэтому она не настолько надежна, как функция, имеющая собственную внутреннюю автоссылку. 

### Имена как дескрипторы

И последний (на мой взгляд, самый важный) момент: если имя функции не указано,  другому человеку (а порой и вам спустя какое-то время) будет сложнее с первого взгляда определить, для чего нужна эта функция. Чтобы разобраться в происходящем,  придется читать больше кода, включая код внутри функции и окружающий код за пределами функции. 
Пример:

```js
[ 1, 2, 3, 4, 5 ].filter(function(v){
    return v % 2 == 1;
});
// [ 1, 3, 5 ]

[ 1, 2, 3, 4, 5 ].filter(function keepOnlyOdds(v){
    return v % 2 == 1;
});
// [ 1, 3, 5 ]
```

Вряд ли можно привести разумный аргумент в пользу того, что исключение имени `keepOnlyOdds` из первого обратного вызова более эффективно передает читателю цель этого обратного вызова. Вы экономите `13` символов, но теряете важную информацию, упрощающую чтение программы. Имя `keepOnlyOdds` предельно четко сообщает читателю, что происходит в программе.

Движок `js` не обращает никакого внимания на имя. Зато оно важно для людей, читающих ваш код.

Сможет ли читатель взглянуть на команду `v % 2 == 1` и определить, что она делает? Безусловно. Но ему придется определять цель (и имя), выполняя код в уме. Даже краткая пауза замедляет чтение кода. С хорошим содержательным именем этот процесс проходит мгновенно и почти без усилий. 

Взгляните на это так: сколько раз автору кода приходится определять цель функции перед добавлением имени в код? Наверно, один. Возможно, два или три, если имя потребуется изменить. Но сколько раз читателю кода придется вычислять это имя/цель? Каждый раз, когда он читает эту строку. Сотни раз? Тысячи? Больше? 

Независимо от длины или сложности функции я считаю, что автор должен подобрать хорошее содержательное имя и включить его в код. Имена должны присваиваться даже однострочным функциям в командах` map(..)` и `then(..)`: 

```js
lookupTheRecords(someData)
.then(function extractSalesRecords(resp){
   return resp.allSales;
})
.then(storeRecords);
```

Отсутствие имени функции может объясняться либо ленью (вы не хотите вводить несколько лишних символов), либо отсутствием творческого мышления (вы не можете придумать хорошее имя). Если вы не можете придумать хорошее имя, скорее всего, вы еще не понимаете саму функцию и ее цель. Возможно, функция плохо спроектирована или пытается решать слишком много задач и нуждается в переработке. Когда у вас появится хорошо спроектированная функция, специализированная для решения одной задачи, ее имя должно стать очевидным. 

Обычно я использую такой прием: если во время первого написания функции я не полностью понимаю ее цель и не могу предложить хорошее имя, то использую имя TODO. Позднее в процессе рецензирования кода я обычно нахожу эти временные имена, и у меня будет больше желания (и больше оснований), чтобы вернуться и придумать более удачное имя вместо TODO. 

Всем функциям нужны имена. Всем без исключений. Любое имя, пропущенное вами, усложняет чтение программы, усложняет ее отладку, расширение и последующее сопровождение. 

### Стрелочные функции

Стрелочные функции всегда анонимны, даже если они (нечасто) используются способом, при котором им присваивается автоматически определенное имя. Я только что потратил несколько страниц, объясняя, чем плохи анонимные функции; вероятно, вы догадываетесь, чем плохи стрелочные функции. 

Не используйте их как общую замену для обычных функций. Да, они более компактны, но за эту компактность приходится расплачиваться ключевыми визуальными ограничителями, которые помогают нашему мозгу быстро разбирать читаемый текст. И в контексте нашего обсуждения они анонимны, что ухудшает их удобочитаемость.

У стрелочных функций есть свое предназначение, но оно не сводится к экономии нескольких нажатий клавиш. Стрелочные функции обладают поведением лексического `this`, что выходит за рамки материала книги. 

Вкратце: стрелочные функции вообще не определяют идентификатор `this` как ключевое слово. Если вы используете `this` внутри стрелочной функции, это имя ведет себя точно так же, как любая другая ссылка на переменную, т. е. происходит поиск по цепочке областей видимости для нахождения области видимости функции (нестрелочной функции), где оно определяется, и использование найденной ссылки. Другими словами, стрелочные функции рассматривают `this` как любую другую *лексическую переменную*. 

Если вы привыкли к трюкам типа `var self = this` или предпочитаете вызывать `.bind(this)` для внутренних функциональных выражений просто для того, чтобы унаследовать `this` от внешней функции, словно это лексическая переменная, то стрелочные функции => однозначно будут лучшим вариантом. Они проектировались специально для решения этой проблемы. 

Таким образом, в редких случаях, когда вам требуется поведение лексического this, используйте стрелочную функцию. Это лучший инструмент для решения вашей задачи. Но помните, что при этом вы соглашаетесь на все недостатки анонимных функций. Вам придется потратить дополнительные усилия, чтобы компенсировать снижение удобочитаемости — например, добавить в код содержательные имена переменных и комментарии.

#### Разновидности IIFE 

У всех функций должны быть имена. Я ведь уже говорил это, да? Это утверждение распространяется и на IIFE: 

```js
(function(){
    // don't do this!
})();

(function doThisInstead(){
    // ..
})();
```

Как выбрать имя для `IIFE`? Определите, для чего существует именно эта `IIFE`. Для чего вам нужна область видимости в этой точке программы? Вы скрываете переменную-кэш для записей с информацией о студентах?

```js
var getStudents = (function StoreStudentRecords(){
    var studentRecords = [];

    return function getStudents() {
        // ..
    }
})();
```

Я присвоил `IIFE` имя` StoreStudentRecords`, потому что оно описывает предназначение `IIFE`: хранение записей студентов. У каждого выражения `IIFE` должно быть имя. Без исключений. 

`IIFE` обычно определяются заключением функционального выражения в круглые скобки (..), как показано в предыдущих фрагментах. Тем не менее это не единственный способ определения `IIFE`. С технической точки зрения первый окружающий набор скобок (..) используется только по одной причине: чтобы ключевое слово function не находилось в позиции, в которой оно могло бы рассматриваться парсером `JS` как объявление функции. Но есть и другие синтаксические способы, предотвращающие его разбор как объявления: 

```js
!function thisIsAnIIFE(){
    // ..
}();

+function soIsThisOne(){
    // ..
}();

~function andThisOneToo(){
    // ..
}();
```

`!,` `+,` `~` и несколько других унарных операторов (операторов с одним операндом) можно поставить перед `function`, чтобы преобразовать объявление в выражение. Тогда последний вызов `()` становится допустимым и превращается в `IIFE`. 

Лично мне нравится использовать унарный оператор `void` при определении автономных `IIFE`:

```js
void function yepItsAnIIFE() { 
// .. 
}(); 
```

Преимущество `void` в том, что этот оператор четко сообщает в начале функции, что `IIFE` не возвращает никакого значения. Как бы вы ни определяли свои `IIFE`, проявите к ним уважение и присвойте имена.

### Поднятие: функции и переменные

В [[5. (Не такой уж) тайный жизненный цикл переменных|главе 5]] было описано как *поднятие* функций, так и *поднятие* переменных. Так как поднятие (`hoisting`) часто характеризуется как ошибка при проектировании `JS`, я хочу кратко объяснить, почему обе формы поднятия могут быть полезными и ими не стоит пренебрегать. Чтобы рассмотреть *поднятие* на более глубоком уровне, вспомните его основные преимущества:
- сначала идет исполняемый код, потом объявления функций;
- семантическое размещение объявлений переменных. 

#### Поднятие функций

Вспомните, что следующая программа работает благодаря поднятию функций:

```js
getStudents(); 
// ..
 function getStudents() { 
 // ..
  } 
```

Объявление `function` поднимается в процессе *компиляции*; это означает, что `getStudents` — идентификатор, объявляемый для всей *области видимости*. Кроме того, идентификатор `getStudents` автоматически инициализируется ссылкой на функцию (также в начале *области видимости*).

Почему это полезно? Я использую *поднятие* функций из-за того, что исполняемый код размещается в любой *области видимости* наверху, а все дальнейшие объявления (функции) — внизу. Это позволяет мне легко найти код, который будет выполняться в любой заданной области, вместо того чтобы прокручивать и прокручивать страницы в поисках закрывающей фигурной скобки }, отмечающей конец области видимости/функции.

Я пользуюсь преимуществами этого обратного позиционирования на всех уровнях области видимости:

```js
getStudents();

// *************

function getStudents() {
    var whatever = doSomething();

    // other stuff

    return whatever;

    // *************

    function doSomething() {
        // ..
    }
}
```

Когда я открываю такой файл, самая первая строка содержит *исполняемый код*, который активизирует его поведение. Найти эту строку несложно, она хорошо видна. Если мне в дальнейшем понадобится найти и просмотреть функцию `getStudents()`, ее первая строка также содержит исполняемый код. И только если понадобится просмотреть подробности того, что делает `doSomething()`, я начинаю искать определение функции внизу. 

Иначе говоря, я думаю, что *поднятие* функций упрощает чтение кода за счет более естественного и последовательного порядка — от начала к концу. 

#### Поднятие переменных 

Как насчет поднятия переменных? Несмотря на то что объявления `let` и `const` поднимаются, эти переменные не могут использоваться в своих зонах `TDZ` (см. [[5. (Не такой уж) тайный жизненный цикл переменных|главу 5]]). Таким образом, следующее обсуждение относится только к объявлениям `var`. Прежде чем продолжать, я должен признать: почти во всех случаях я полностью согласен с тем, что *поднятие переменных* — **неудачная идея**: 

```js
pleaseDontDoThis = "bad idea"; 
// much later 
var pleaseDontDoThis;
```

Хотя подобное обратное позиционирование было полезно для поднятия функций, в данном случае я считаю, что оно обычно усложняет анализ кода.

Однако существует одно исключение, которое встречается — хотя и редко — в моих программах. Оно связано с тем, где я размещаю объявления `var` в определениях модулей `Commonjs`.

Типичная структура определения модулей в `Node` выглядит так: 

```js
// dependencies
var aModuleINeed = require("very-helpful");
var anotherModule = require("kinda-helpful");

// public API
var publicAPI = Object.assign(module.exports,{
    getStudents,
    addStudents,
    // ..
});

// ********************************
// private implementation

var cache = { };
var otherData = [ ];

function getStudents() {
    // ..
}

function addStudents() {
    // ..
}
```

Обратите внимание: переменные `cache` и `otherData` находятся в «*приватном*» разделе структуры модуля. Дело в том, что я не планирую предоставлять их для открытого доступа. По этой причине я выбираю такую структуру модуля, чтобы они находились вместе с другими скрытыми подробностями реализации модуля. 

Но я видел несколько редких случаев, в которых мне требовалось выполнить присваивание этих значений выше, до объявления экспортируемого открытого `API` модуля. Пример: 

```js
// public API
var publicAPI = Object.assign(module.exports,{
    getStudents,
    addStudents,
    refreshData: refreshData.bind(null,cache)
});
```

Было нужно, чтобы переменной `cache` уже было присвоено значение, потому что это значение используется при инициализации открытого `API` (частичное применение `the .bind(..)`). 

Следует ли переместить команду `var cache = { .. }` наверх, перед инициализацией открытого `API`? Возможно. Но тогда становится менее очевидно, что `var cache` является подробностью приватной реализации. Компромиссное решение, которое я применял (достаточно редко):

```js
cache = {};   // used here, but declared below

// public API
var publicAPI = Object.assign(module.exports,{
    getStudents,
    addStudents,
    refreshData: refreshData.bind(null,cache)
});

// ********************************
// private implementation

var cache /* = {}*/;
```

Видите эффект поднятия переменной? Я объявил переменную `cache` там, где ей место (логически), но в этом редком случае я воспользовался ей выше, в той области, где нужно, чтобы она была инициализирована. Я даже оставил подсказку о значении, которое присваивается `cache`, в комментарии.

И это буквально единственный случай, в котором я использую поднятие переменной для присваивания значения, предшествующего объявлению переменной. Но я считаю, что это разумное исключение, которым следует пользоваться осторожно. 

### В защиту `var`

Раз уж речь зашла о *поднятии* переменных, поговорим немного о `var` — *любимом «злодее» многих разработчиков*, которого они обвиняют во многих грехах. [[5. (Не такой уж) тайный жизненный цикл переменных#Повторное объявление?|В главе 5]] мы изучили объявления `let`/`const` и я пообещал вернуться к теме и показать, какое место `var` занимает в общей картине. 

И пока я буду приводить аргументы, помните:
- объявления `var` никогда не были сломаны;
- `let` — ваш друг;
- полезность `const` ограниченна; 
- используйте лучшее из обоих миров: `var` и `let`. 

#### Не отказывайтесь от var

С объявлениями `var` все нормально, и они прекрасно работают. *Они существовали около 25 лет* и будут жить еще столько же. Утверждения о том, что объявления `var` сломаны, устарели, опасны или плохо спроектированы, — массовое заблуждение. Означает ли это, что `var` идеально подходит для каждого объявления в вашей программе? Конечно, нет. Но место в ваших программах для него все же найдется. Отказываться от его использования только из-за того, что кто-то в вашей команде выбрал агрессивный режим синтаксического анализатора, который поперхнулся на `var`, — значит действовать по принципу «*назло маме уши отморожу*».

А теперь, когда вы разозлились, объясню свою позицию. 

Для протокола: я поклонник `let` для объявлений с *блоковой областью видимости*. Мне не нравится `TDZ`, и я думаю, что это было ошибкой. Но объявления `let` сами по себе превосходны. Я часто пользуюсь ими. Наверное, пользуюсь ими не реже, а то и чаще, чем `var`.
#### Постоянная путаница с const

С другой стороны, ключевым словом `const` я пользуюсь не так часто. Не буду углубляться в подробные объяснения, почему это так, но все сводится к тому, что использование `const` просто не стоит того. Другими словами, хотя в некоторых случаях `const` может принести определенную пользу, эти преимущества компенсируются многолетними неприятностями, связанными с неправильным пониманием `const` в разных языках еще задолго до его включения в `js`.

Многие считают, что `const` создает значения, которые не могут изменяться (ошибочное представление, в высшей степени распространенное в сообществах разработчиков во многих языках), тогда как в действительности оно всего лишь запрещает повторное присваивание. 


```js
const studentIDs = [ 14, 73, 112 ]; 
// позднее 
studentIDs.push(6);
 // стоп, погодите... что?! 
```

Используя `const` с изменяемым значением (таким как *массив* или *объект*), вы расставляете ловушку будущему разработчику (или читателю) вашего кода. Дело в том, что неизменяемость значений — совсем не то же самое, что неизменяемость по присваиванию.

Я просто считаю, что не следует расставлять эти ловушки. Сам я использую `const` только в одной ситуации — когда присваивается уже неизменяемое значение (например, `42` или "`Hello, friends!`") и когда идентификатор является константой в том смысле, что он становится именованным заместителем для литерального значения для семантических целей. Именно для таких применений `const` подходит лучше всего. Впрочем, в моем коде такие случаи встречаются относительно редко. 

Если бы повторное присваивание переменным было серьезной проблемой, то использование `const` было бы более полезным. Однако повторное присваивание не играет заметной роли в причине ошибок. Список факторов, которые могут вызвать ошибки в программах, достаточно длинный, но случайное повторное присваивание находится далеко не в первых позициях этого списка. 

Объединим это с тем фактом, что `const` (и `let`) *предназначено для использования в блоках*, а блоки должны быть короткими, так что сама область, в которой могут применяться объявления `const`, весьма невелика. `const` в строке 1 нашего 10-строчного блока только говорит вам что-то о следующих девяти строках. Причем то, что оно вам говорит, становится и так очевидно при взгляде на эти девять строк: переменная никогда не находится слева от `=;` ей нигде не присваивается значение повторно. 

И это все, что реально делает `const`. В остальном оно бесполезно. Если сравнить с серьезной путаницей с неизменяемостью значений/неизменяемостью по присваиванию, `const` в значительной мере теряет часть своей привлекательности. 

Объявление `let` (или `var`!), которой нигде не присваивается значение повторно, уже является «`константой`» с точки зрения поведения, хотя эта «константность» не имеет гарантий компилятора. В большинстве случаев этого вполне достаточно. 

#### var и let 

В моем представлении `const` редко приносит пользу, так что в гонке фактически участвуют только `let` и `var`. Впрочем, это вряд ли можно назвать гонкой, потому что единственного победителя не будет. Выиграть могут сразу двое… каждый в своем классе. 

Дело в том, что вам в своих программах стоит использовать как `var`, так и `let`. Эти ключевые слова не являются взаимозаменяемыми; не используйте `var` там, где ситуация требует `let`, но также и не стоит использовать `let` там, где наиболее уместным будет `var`. 

Где же использовать ключевое слово `var`? В каких обстоятельствах оно подойдет лучше, чем `let`? 

Прежде всего, я всегда использую `var` в области видимости верхнего уровня любой функции независимо от того, находится ли оно в начале, середине или конце функции. Также я использую `var` в глобальной области видимости, хотя и стараюсь свети использование глобальной области видимости к минимуму. 

Зачем использовать `var` для функциональной *области видимости*? Потому что `var` делает именно это. Для задачи определения функциональной области видимости для объявления буквально не существует лучшего инструмента, чем тот, который делал именно это в течение 25 лет.

Вы можете использовать `let` в этой *области видимости верхнего уровня*, но это не лучший инструмент для такой задачи. Я также обнаружил, что если вы будете использовать `let` повсюду, будет менее очевидно, какие объявления были спроектированы как локализованные, а какие должны использоваться по всей функции. 

С другой стороны, я редко использую `var` внутри блока. Для этого существует `let`. Используйте наиболее подходящий инструмент для задачи. Если вы видите ключевое слово `let`, оно сообщает, что вы имеете дело с локализованным объявлением. Если вы видите ключевое слово `var`, оно сообщает, что вы имеете дело с объявлением верхнего уровня функции. В общем, все просто. 

```js
function getStudents(data) {
    var studentRecords = [];

    for (let record of data.records) {
        let id = `student-${ record.id }`;
        studentRecords.push({
            id,
            record.name
        });
    }

    return studentRecords;
}
```

Переменная `studentRecords` предназначена для использования в границах всей функции. `var` — лучший инструмент, который сообщит читателю кода эту информацию. С другой стороны, `record` и `id` предназначены для использования только в более узкой *области видимости* итерации цикла, поэтому для этой цели лучше всего подойдет `let`. 

Помимо семантического аргумента о наиболее подходящем инструменте ключевое слово `var` также обладает рядом характеристик, которые в некоторых ограниченных обстоятельствах делают его более мощным.

Один из примеров — когда переменная используется исключительно в цикле, но его условная секция не видит объявлений блоковой видимости внутри итерации: 

```js
function commitAction() {
    do {
        let result = commit();
        var done = result && result.code == 1;
    } while (!done);
}
```

Здесь переменная result очевидно используется только внутри блока, поэтому мы выбираем `let`. Но переменная `done` — другое дело. Она полезна только в границах цикла, но секция `while` не видит объявления `let`, расположенные внутри цикла. По этой причине мы идем на компромисс и используем `var`, чтобы переменная `done` поднималась во *внешнюю область видимости* и была видна в ней. 

*Альтернатива* — объявление `done` за пределами цикла — отделяет ее от места первого использования и заставляет вас либо выбрать значение по умолчанию, либо, что еще хуже, оставить переменную без присваивания и создать неоднозначность для читателя кода. Я думаю, что решение с `var` внутри цикла здесь будет предпочтительным. 

Другая полезная характеристика `var` проявляется в объявлениях внутри непреднамеренных блоков. Непреднамеренными называются блоки, которые создаются, потому что синтаксису требуется блок, но разработчик на самом деле не собирался создавать *локализованную область видимости*. Лучшей иллюстрацией непреднамеренных областей видимости служит команда `try.. catch`: 

```js
function getStudents() {
    try {
        // not really a block scope
        var records = fromCache("students");
    }
    catch (err) {
        // oops, fall back to a default
        var records = [];
    }
    // ..
}
```

Да, есть и другие способы структурирования этого кода. Но думаю, что это лучший вариант с учетом всех плюсов и минусов. 

Я не хочу объявлять переменную `records` (с `var` или `let`) за пределами блока `try`, а затем присваивать ей значение в одном или обоих блоках. Я предпочитаю, чтобы исходные объявления были как можно ближе (в идеале в одной строке) к первому использованию переменной. В этом простом примере расстояние может составлять всего пару строк, но в реальном коде таких строк может быть намного больше. Чем больше разрыв, тем сложнее определить, какой переменной из какой *области видимости* присваивается значение. Ключевое слово `var`, используемое при фактическом присваивании, делает его более однозначным. 

Также обратите внимание на то, что я использовал `var` в обоих блоках, `try` и `catch`. Этим я хотел дать сигнал читателю кода, что переменная `records` будет объявлена при любом выборе пути. Технически это решение работает, потому что `var` поднимается только один раз в *область видимости* функции. Тем не менее это хороший семантический сигнал, который напомнит читателю кода, что обеспечивает каждое из объявлений `var`. Если бы ключевое слово `var` использовалось только в одном из блоков, а вы бы прочитали только другой блок, то не смогли бы так же легко понять, откуда взялась переменная `records`. 

И в этом, как мне кажется, заключается маленькая *суперспособность* `var`. Это объявление может не только обходить непреднамеренные блоки `try..catch`, но и многократно встречаться в *области видимости функции*. С `let` такое сделать невозможно. В этом нет ничего плохого, это маленькая полезная возможность. Рассматривайте `var` как декларативную аннотацию, которая при каждом использовании напоминает вам, откуда взялась переменная. «Ага, правильно, она принадлежит всей функции». 

Эта *суперспособность* повторяемой аннотации может пригодиться и в других случаях: 

```js
function getStudents() {
    var data = [];

    // do something with data
    // .. 50 more lines of code ..

    // purely an annotation to remind us
    var data;

    // use data again
    // ..
}
```

Вторая конструкция `var data` не является переобъявлением `data`; она всего лишь указывает читателю кода, что `data` *объявляется на уровне функции*. Благодаря этому читателю не придется прокручивать код вверх на 50+ строк, чтобы найти исходное объявление.

Я абсолютно нормально отношусь к повторному использованию переменных для нескольких целей в *области видимости функции*. Я также абсолютно нормально отношусь к двум сценариям использования переменных, разделенных лишь несколькими строками кода. В обоих случаях возможность безопасного повторного объявления (а на самом деле аннотации) командой `var helps` поможет всегда знать, откуда взялись мои данные, независимо от того, где я нахожусь в функции. 

И снова `let`, как ни печально, сделать этого не сможет. 

Также есть другие нюансы и сценарии, в которых `var` приносит некоторую пользу, но я не собираюсь развивать эту тему. А значит, `var` может пригодиться в наших программах наряду с `let` (и отдельных вкраплений `const`). Вы же хотите творчески использовать инструменты, предоставляемые языком `js`, чтобы донести более содержательную информацию для читателей вашего кода? 

Не отказывайтесь от такого полезного инструмента, как `var`, только потому, что кто-то *пристыдил вас* и заставил думать, что *это уже не круто*. Не избегайте объявлений `var` из-за того, что когда-то вы на них споткнулись. Изучите эти инструменты и используйте каждый из них для тех задач, для которых они лучше подходят. 

### Для чего была создана TDZ?

Концепция `TDZ` (*Temporal Dead Zone*) объяснялась в [[5. (Не такой уж) тайный жизненный цикл переменных#Неинициализированные переменные (TDZ)|главе 5]]. Я показал, как она возникает в программе, но не объяснил, почему было необходимо вводить ее в `js`. Кратко рассмотрим основные причины для создания `TDZ`. 

Некоторые ключевые моменты в истории происхождения `TDZ`:
- `const` не могут изменяться; 
- все дело во времени; 
- должны ли объявления `let` быть больше похожими на `const` или `var`?

#### С чего все началось 

На самом деле область `TDZ` появилась из-за `const`. 

В начале разработки `ES6` комитету *TC39* пришлось решать, должны ли `const` (и `let`) подниматься в начало своих блоков. Было решено, что эти объявления должны подниматься по аналогии с тем, как это происходит с `var`. В противном случае, я думаю, что опасения были отчасти обусловлены возможной путаницей из-за замещения в середине области видимости:

```js
let greeting = "Hi!";

{
    // what should print here?
    console.log(greeting);

    // .. a bunch of lines of code ..

    // now shadowing the `greeting` variable
    let greeting = "Hello, friends!";

    // ..
}
```

Что делать с командой `console.log(..)`? Если команда просто выведет «`Hi!`», будет ли это разумно с точки зрения разработчика `js`? Получается, что затенение начинает работать только во второй половине блока, а в первой не работает — это выглядит довольно странно. Такое поведение не интуитивно и не похоже на `js`. Соответственно, объявления `let` и `const` должны подниматься в начало блока и быть видимыми повсюду. 

Но если `let `и `const `поднимаются в начало блока (подобно тому как `var` поднимается в начало функции), почему бы не разрешить `let` и `const` автоматически инициализироваться (значением `undefined`) по аналогии с `var`? Следующий пример демонстрирует основную проблему:

```js
{
    // what should print here?
    console.log(studentName);

    // later

    const studentName = "Frank";

    // ..
}
```

Представьте, что `studentName` не только поднимается в начало блока, но и автоматически инициализируется значением `undefined`. В первой половине блока переменная `studentName` будет иметь наблюдаемое значение `undefined` (это относится к команде `console. log(..)`). После достижения команды `const studentName = .. `переменной `studentName` теперь присваивается значение `"Frank"`. С этой точки и далее переменной `studentName` уже невозможно присвоить новое значение. 

Но разве не будет странно и удивительно выглядеть то, что константа наблюдаемо имеет два разных значения — сначала `undefined`, затем `"Frank"`? Это вроде бы противоречит нашим представлениям о смысле константы — она должна наблюдаться только с одним значением.

Итак… возникает проблема. Мы не можем автоматически инициализировать `studentName` значением `undefined` (или любым другим, если на то пошло). Но переменная должна существовать во *всей области видимости*. Что делать с периодом от того момента, когда она начинает существовать (`начало области видимости`), и до того, как ей будет присвоено значение? Мы называем этот период времени мертвой зоной, или `TDZ` (*Temporal Dead Zone*). Для предотвращения путаницы было определено, что любые обращения к переменной, находящейся в области `TDZ`, недопустимы и должны приводить к ошибке `TDZ`. Окей, признаю — эта цепочка рассуждений выглядит разумно. 

#### TDZ и let

Но пока речь шла только о `const`. А как насчет `let`?

Комитет *TC39* принял решение: так как нам нужны `TDZ` для `const`, то можно предусмотреть `TDZ` и для `let`. Собственно, добавляя `TDZ` для `let`, мы тем самым отбиваем у людей охоту использовать уродливое поднятие переменных. Так что здесь выбор объяснялся логической целостностью и, возможно, желанием добавить некоторую долю социотехники, чтобы повлиять на поведение разработчиков. 

Мои возражения: если вы хотите логической целостности, то равняйтесь на `var`, а не на `const`; у `let` определенно больше общего с `var`, чем с `const`. Это особенно справедливо, потому что согласованность с `var` уже была выбрана для всей концепции поднятия в начало области видимости. Пусть `const` будет особым случаем с `TDZ`, и пусть проблема с `TDZ` решается легко: просто избегайте `TDZ`, всегда объявляя свои константы в начале области видимости. На мой взгляд, это было бы более разумно. 

Но, к сожалению, вышло все не так. `let` имеет `TDZ`, потому что `TDZ` необходима для `const`, из-за того что `let` и `const` следуют примеру `var` с поднятием в начало (блоковой) области видимости. Голова идет кругом? Перечитайте несколько раз. 

### Остаются ли синхронные обратные вызовы замыканиями? 

В [[7. Использование замыканий|главе 7]] были представлены два разных модуля для осмысления замыканий:
- замыкание рассматривается как экземпляр функции, запоминающей свои внешние переменные, даже если эта функция передается и вызывается в других областях видимости;
- замыкание рассматривается как экземпляр функции, окружение области видимости которого сохраняется на месте, а ссылки на эту функцию передаются и вызываются из других областей видимости. 

Эти модели не так уж сильно отличаются, но они рассматривают происходящее с разных точек зрения. И эти точки зрения изменяют то, что мы определяем как замыкание. 

Не заплутайте на этой извилистой тропе со всеми ее замыканиями и обратными вызовами: 
- обратный вызов чего (или где)?
- возможно, термин «синхронный обратный вызов» выбран неудачно;
- функции `IIF` не перемещаются, зачем им замыкание?
- временная задержка — ключевой фактор для замыканий. 

#### Что такое обратный вызов?

Прежде чем возвращаться к *замыканиям*, потрачу еще немного времени на объяснение термина «*обратный вызов*» (`callback`). Обычно считается, что обратный вызов включает как *асинхронные*, так и *синхронные* обратные вызовы. На мой взгляд, это не лучшая идея. Хочу объяснить, почему я так считаю, и предложить другой термин. 

Начнем с *асинхронного* обратного вызова — ссылки на функцию, которая будет вызвана позднее. *Что означает обратный вызов в этом случае*? 

Он означает, что текущий код завершился, сделал паузу или приостановил свое выполнение и что при последующем вызове этой функции управление передается приостановленной программе, что приводит к возобновлению ее выполнения. А конкретнее, точкой повторного входа становится код, «*завернутый*» в ссылку на функцию:

```js
setTimeout(function waitForASecond(){
    // this is where `js` should call back into
    // the program when the timer has elapsed
},1000);

// this is where the current program finishes
// or suspends
```

В этом контексте термин «обратный вызов» выглядит разумно. Движок `js` возобновляет приостановленную программу, обращаясь с обратным вызовом в конкретную точку. Хорошо, обратный вызов в данном случае работает *асинхронно*. 

### Синхронный обратный вызов? 

Но как насчет *синхронных обратных вызовов*? Пример

```js
function getLabels(studentIDs) {
    return studentIDs.map(
        function formatIDLabel(id){
            return `Student ID: ${
               String(id).padStart(6)
            }`;
        }
    );
}

getLabels([ 14, 73, 112, 6 ]);
// [
//    "Student ID: 000014",
//    "Student ID: 000073",
//    "Student ID: 000112",
//    "Student ID: 000006"
// ]
```

Стоит ли называть `formatIDLabel(..)` *обратным вызовом*? Действительно ли функция `map(..)` обращается с обратным вызовом к программе, вызывая предоставленную нами функцию?

Здесь нет никакого обратного вызова как такового, потому что программа не приостанавливается и не завершается. Мы передаем функцию (вернее, ссылку) из одной части программы в другую, после чего немедленно вызываем ее.

Есть и другие устоявшиеся термины, которые могут подойти для решаемой задачи — передача функции (вернее, ссылки), чтобы другая часть программы могла вызвать ее по вашему поручению. Происходящее можно рассматривать как внедрение зависимостей (*DI, Dependency Injection*) или инверсию управления (*IoC, Inversion of Control*).

*DI* можно охарактеризовать как передачу необходимых частей функциональности другим частям программы, чтобы их можно было вызывать для завершения их операций. Это описание неплохо подходит для вызова `map(..)`, не правда ли? Вспомогательная функция `map(..)` умеет перебирать значения в списке, но не знает, что делать с этими значениями. Именно поэтому мы передаем ей функцию `formatIDLabel(..)`. Мы передаем зависимость.

*IoC* — довольно похожая взаимосвязанная концепция. Инверсия управления означает, что происходящее в программе не находится под управлением текущей области программы — вы передаете управление другой части программы. Мы завернули логику вычисления строки метки в функцию `formatIDLabel(..)`, а затем передали управление ее вызовом функции `map(..)`. 

Стоит заметить, что Мартин Фаулер (Martin Fowler) приводит *IoC* как признак, по которому можно отличить фреймворк от библиотеки: вы вызываете функции библиотеки, а фреймворк вызывает ваши [^1]функции. 

В контексте нашего обсуждения как *DI*, так и *IoC* может послужить альтернативным термином для синхронных обратных вызовов. 

Однако у меня есть другое предложение. Будем называть синхронные обратные вызовы (вернее, функции, которые мы так ранее называли) `IIF` (Inter-Invoked Functions, т. е. функции опосредованного вызова). Да, конечно, я здесь обыгрываю термин `IIFE`. Такие виды функций вызываются опосредованно, т. е. они вызываются другой сущностью (в отличие от `IIFE`, которые вызывают сами себя непосредственно). 

Какими же отношениями связываются асинхронные обратные вызовы с `IIF`? Асинхронный обратный вызов — это функция `IIF`, которая вызывается асинхронно, а не синхронно.

#### Синхронные замыкания? 

Итак, мы присвоили синхронным обратным вызовам новое название `IIF`, и мы можем вернуться к главному вопросу: являются ли IIF примером замыкания? Очевидно, IIF должна обращаться к переменным из внешней области видимости, чтобы она могла считаться замыканием.` IIF formatIDLabel(..)` из предыдущего примера не обращается ни к каким переменным вне своей области видимости, поэтому она определенно не является замыканием. 

Как насчет IIF с внешними ссылками? Являются ли они замыканиями? 

[^1]: nversion of Control, Martin Fowler, https://martinfowler.com/bliki/Inversion OfControl.html, 26 июня 2005 г.

```js
function printLabels(labels) {
    var list = document.getElementById("labelsList");

    labels.forEach(
        function renderLabel(label){
            var li = document.createElement("li");
            li.innerText = label;
            list.appendChild(li);
        }
    );
}
```

Внутренняя `IIF renderLabel(..)` обращается к list из окружающей области видимости, поэтому в данном случае `IIF` может иметь замыкание. Но здесь начинают играть важную роль определение/ модель, выбранные нами для замыкания. 
Если renderLabel(..) является функцией, которая передается в другую точку, и эта функция затем вызывается, тогда renderLabel(..) действительно проявляет замыкание, потому что замыкание должно сохранять свой доступ к исходной цепочке областей видимости.
Но если, как описано в альтернативной концептуальной модели из [[7. Использование замыканий#Альтернативная точка зрения|главы 7]], `renderLabel(..)` остается на месте, и `forEach(..)` передается только ссылка, есть ли какая-то необходимость в том, чтобы замыкание сохраняло цепочку областей видимости `renderLabel(..)`, пока она выполняется синхронно прямо внутри своей области видимости? 

Нет. Это обычная *лексическая область видимости*. 

Чтобы понять, почему это происходит, рассмотрим альтернативную форму `printLabels(..)`:

```js
function printLabels(labels) {
    var list = document.getElementById("labelsList");

    for (let label of labels) {
        // just a normal function call in its own
        // scope, right? That's not really closure!
        renderLabel(label);
    }

    // **************

    function renderLabel(label) {
        var li = document.createElement("li");
        li.innerText = label;
        list.appendChild(li);
    }
}
```

Эти две версии` printLabels(..)` фактически одинаковы. 

Вторая версия определенно не является примером исключения, по крайней мере ни в каком полезном или наблюдаемом смысле. Это всего лишь *лексическая видимость*. Первая версия, в которой `forEach(..)` вызывает нашу функцию, фактически делает то же самое. Она тоже является не замыканием, а простой функцией в *лексической области видимости*.

#### Временная задержка 

Кстати, в [[7. Использование замыканий#^15c4f9|главе 7]] кратко упоминались механизмы частичного применения и *каррирования* (зависящие от замыкания). Это интересный сценарий, в котором может применяться ручное *каррирование*: 

```js
function printLabels(labels) {
    var list = document.getElementById("labelsList");
    var renderLabel = renderTo(list);

    // definitely closure this time!
    labels.forEach( renderLabel );

    // **************

    function renderTo(list) {
        return function createLabel(label){
            var li = document.createElement("li");
            li.innerText = label;
            list.appendChild(li);
        };
    }
}
```

Внутренняя функция `createLabel(..)`, которую мы присваиваем `renderLabel`, замыкается на `list`, так что здесь определенно используется *замыкание*. 

*Замыкание* позволяет нам запомнить `list` на будущее, тогда как выполнение фактической логики создания меток откладывается от вызова `renderTo(..)` до последующих вызовов `IIF` `createLabel(..)` из `forEach(..).` Возможно, это будет лишь совсем короткий момент, но теоретически продолжительность может быть любой.

### Вариации на тему классических модулей 

В [[8. Паттерн МОДУЛЬ#Определение классического модуля|главе 8]] рассматривался паттерн «*Классический модуль*», который выглядит примерно так: 

```js
var StudentList = (function defineModule(Student){
    var elems = [];

    var publicAPI = {
        renderList() {
            // ..
        }
    };

    return publicAPI;

})(Student);
```

Следует заметить, что мы передаем `Student` (другой экземпляр модуля) как зависимость. Однако у этой формы *модуля* существует много полезных модификаций. Следующие подсказки помогут вам распознать эти вариации:

- знает ли модуль о своем API?
- даже если мы используем изощренный загрузчик модуля, это всего лишь классический модуль;
- некоторые модули должны работать универсально.

#### Где мой API? 

Прежде всего, большинство классических модулей не определяет и не использует `publicAPI` так, как я показал в этом коде. Вместо этого они выглядят примерно так: 

```js
var StudentList = (function defineModule(Student){
    var elems = [];

    return {
        renderList() {
            // ..
        }
    };

})(Student);
```

Этот пример отличается только одним: в нем напрямую возвращается объект, который служит открытым `API` для модуля, вместо предварительного сохранения его во внутренней переменной `publicAPI`. *Так определяется подавляющее большинство классических модулей.* 

Но я безусловно предпочитаю и всегда использую сам первую форму с `publicAPI`. Это объясняется двумя причинами:
- `publicAPI` — семантический дескриптор, который упрощает чтение программы, наглядно поясняя предназначение объекта;
- внутренняя переменная `publicAPI`, которая ссылается на тот же объект внешнего открытого `API`, может быть полезной, если вам потребуется обратиться или изменить `API` на протяжении срока жизни модуля.

Например, вы можете захотеть вызвать одну из общедоступных функций внутри модуля. А может быть, вы захотите добавить или удалить методы в зависимости от некоторых условий или обновить предоставляемое свойство. В любом случае отказ от хранения ссылки для обращения к собственному `API` выглядит довольно странно. Не так ли? 

#### Асинхронное определение модуля (AMD)

Другая разновидность классических модулей — модули в стиле `AMD` (которые были популярны несколько лет назад) вроде тех, которые поддерживаются Require`js`:

```js
define([ "./Student" ],function StudentList(Student){
    var elems = [];

    return {
        renderList() {
            // ..
        }
    };
});
```

Если внимательно присмотреться к `StudentList(..),` мы видим, что это *фабричная функция классического модуля.* Внутренние механизмы `define(..)` (предоставляется `Requirejs`) выполняют функцию `StudentList(..)`, передавая ей любые экземпляры модулей, объявленные как зависимости. Возвращаемым значением является объект, представляющий открытый `API` для модуля. 

Все происходящее базируется на абсолютно тех же принципах (включая работу замыканий), которые были описаны для *классических модулей*.

### Универсальные модули (UMD) 

Последняя разновидность модулей, которую мы рассмотрим — `UMD`, — является не столько конкретным точным форматом, сколько коллекцией очень похожих форматов. Она была спроектировала для улучшения взаимодействия (без преобразований средствами сборки) для модулей, которые могут загружаться в браузерах загрузчиками в стиле `AMD` или в `Node`. Лично я все еще публикую многие из своих вспомогательных библиотек в форме `UMD`.

Типичная структура UMD выглядит так: 

```js
(function UMD(name,context,definition){
    // loaded by an AMD-style loader?
    if (
        typeof define === "function" &&
        define.amd
    ) {
        define(definition);
    }
    // in Node?
    else if (
        typeof module !== "undefined" &&
        module.exports
    ) {
        module.exports = definition(name,context);
    }
    // assume standalone browser script
    else {
        context[name] = definition(name,context);
    }
})("StudentList",this,function DEF(name,context){

    var elems = [];

    return {
        renderList() {
            // ..
        }
    };

});
```

И хотя структура выглядит немного необычно, `UMD` в действительности является выражением `IIFE`. 

Отличается здесь то, что главная часть функционального выражения (наверху) `IIFE` содержит серию команд `if..else` для определения одной из трех поддерживаемых сред, в которой загружается модуль. 

В последних круглых скобках ``()``, которые обычно вызывают `IIFE`, передаются три аргумента: `"StudentsList"`, `this` и другое *функциональное выражение*. Сопоставив эти аргументы со своими параметрами, вы увидите, что это `name`, `context` и `definition` соответственно. `"StudentList"` (`name`) содержит имя модуля, в основном на случай его определения как глобальной переменной. `this` (`context`) обычно соответствует `window` (т. е. *глобальному объекту*; см. [[4. Глобальная область видимости#Объект `window` в браузере|главу 4]]) для определения *модуля* по имени. `definition(..)` вызывается для фактического получения определения модуля, и можно заметить, что это просто *классическая форма модуля*!

Невозможно отрицать, что на момент написания книги модули `ESM`(`ES Modules`) набирают популярность и стремительно распространяются. Но за последние 20 лет были написаны миллионы модулей, и во всех использовались те или иные разновидности *классических модулей*, предшествовавшие `ESM`, поэтому все еще очень важно уметь читать и понимать их. 

## Введение

Привет! Я профессор Франклин Фрисби. Приятно познакомиться. Мы проведем некоторое время вместе, так как я должен научить вас немного *функциональному программированию*. Но хватит обо мне, а как насчет вас? Я надеюсь, что вы хотя бы немного знакомы с языком `JavaScript`, имеете небольшой опыт в *объектно-ориентированном программировании* и считаете себя практикующим программистом . Вам не нужно иметь докторскую степень по энтомологии, вам просто нужно знать, как найти и "убить несколько [^1]жучков".

Я не буду предполагать, что у вас есть какие-либо предварительные знания по функциональному программированию, потому что мы оба знаем, что бывает, когда делаешь подобные предположения. Однако я ожидаю, что вы сталкивались с некоторыми неблагоприятными ситуациями, возникающими при работе с изменяемым состоянием, неограниченными побочными эффектами и беспринципным дизайном (кода). Теперь, когда мы должным образом познакомились, давайте приступим к делу.

Цель этой главы — дать вам представление о том, к чему мы стремимся, когда пишем функциональные программы. Чтобы понять следующие главы, мы должны иметь некоторое представление о том, что делает программу *функциональной*. В противном случае мы будем бессмысленно строчить код, избегая объектов (ООП) любой ценой — что, безусловно, будет нелепым занятием. Нам нужна четкая цель, к которой мы будем стремиться, некий небесный компас, когда воды становятся бурными.

*Существует несколько общих принципов программирования* — различные аббревиатуры, которые помогают нам пройти через темные туннели любого приложения: *DRY* (don't repeat yourself - не повторяй написанное), *YAGNI* (ya ain't gonna need it тебе это не понадобится), *loose coupling high cohesion*(слабая связь, высокая сплоченность), *the principle of least surprise* (принцип наименьшего удивления), *single responsibility*(единственная ответственность) и так далее.

Я не буду утомлять вас перечислением всех принципов, о которых я слышал за эти годы... Суть в том, что они работают в функциональной среде, хотя и имеют лишь косвенное отношение к нашей конечной цели. Прежде чем мы пойдем дальше, я хотел бы, чтобы вы почувствовали наше намерение, когда мы нажимаем на кнопочки  клавиатуры; наш функциональный [^2]Xanadu.

## Короткое прикосновение

Начнем с небольшого безумия. Вот приложение с чайками. Когда стаи объединяются, они становятся больше, а когда размножаются, их количество увеличивается на количество чаек, с которыми они размножаются. Обратите внимание, что это не является хорошим *объектно-ориентированным* кодом, он здесь для того, чтобы подчеркнуть опасности нашего современного подхода, основанного на присвоении. Смотрите:

```js
class Flock {
  constructor(n) {
    this.seagulls = n;
  }

  conjoin(other) {
    this.seagulls += other.seagulls;
    return this;
  }

  breed(other) {
    this.seagulls = this.seagulls * other.seagulls;
    return this;
  }
}

const flockA = new Flock(4);
const flockB = new Flock(2);
const flockC = new Flock(0);
const result = flockA
  .conjoin(flockC)
  .breed(flockB)
  .conjoin(flockA.breed(flockB))
  .seagulls;
// 32
```

Кто, черт возьми, мог создать такую ужасную мерзость? Неразумно сложно отслеживать меняющееся внутреннее состояние. И, боже мой, ответ даже неверный! Должно было быть `16`, но `flockA` в процессе оказался навсегда измененным. Бедный `flockA`. Это анархия в *ИТ*! Это арифметика диких животных!
  
Если вы не понимаете эту программу, ничего страшного, я тоже не понимаю. Главное, что нужно запомнить, — это то, что состояние и изменяемые значения трудно отслеживать даже в таком небольшом примере.

Давайте попробуем еще раз, на этот раз используя более функциональный подход:

```js
const conjoin = (flockX, flockY) => flockX + flockY;
const breed = (flockX, flockY) => flockX * flockY;

const flockA = 4;
const flockB = 2;
const flockC = 0;
const result =
    conjoin(breed(flockB, conjoin(flockA, flockC)), breed(flockA, flockB));
// 16
```

Ну, на этот раз мы получили правильный ответ. С гораздо меньшим количеством кода. Вложение функций немного сбивает с толку... (мы исправим эту ситуацию в главе 5). Так лучше, но давайте копнем немного глубже. Есть преимущества в том, чтобы называть вещи своими именами. Если бы мы более внимательно изучили наши пользовательские функции, мы бы обнаружили, что работаем просто с простым сложением (conjoin) и умножением (breed).

В этих двух функциях нет ничего особенного, кроме их названий. Давайте переименуем наши пользовательские функции в multiply и add, чтобы раскрыть их истинную сущность.

```js
const add = (x, y) => x + y;
const multiply = (x, y) => x * y;

const flockA = 4;
const flockB = 2;
const flockC = 0;
const result =
    add(multiply(flockB, add(flockA, flockC)), multiply(flockA, flockB));
// 16
```

И благодаря этому мы обретаем знания древних:

```js
// associative
add(add(x, y), z) === add(x, add(y, z));

// commutative
add(x, y) === add(y, x);

// identity
add(x, 0) === x;

// distributive
multiply(x, add(y,z)) === add(multiply(x, y), multiply(x, z));
```

Ах да, эти старые верные математические свойства должны пригодиться. Не беспокойтесь, если вы не знаете их наизусть. Для многих из нас прошло уже много времени с тех пор, как мы изучали эти законы арифметики. Давайте посмотрим, сможем ли мы использовать эти свойства для упрощения нашей маленькой программы про чайку.

```js
// Original line
add(multiply(flockB, add(flockA, flockC)), multiply(flockA, flockB));

// Apply the identity property to remove the extra add
// (add(flockA, flockC) == flockA)
add(multiply(flockB, flockA), multiply(flockA, flockB));

// Apply distributive property to achieve our result
multiply(flockB, add(flockA, flockA));
```

Блестяще! Нам не пришлось писать ни строчки пользовательского кода, кроме нашей вызывающей функции. Для полноты картины мы включили здесь определения сложения и умножения, но на самом деле нет необходимости их писать — у нас наверняка есть сложение и умножение, предоставляемые какой-нибудь существующей библиотекой.
 
Вы, возможно, думаете: «Как же это несерьезно с вашей стороны приводить такой математический пример в начале». Или: «Реальные программы не так просты и не могут быть описаны таким образом». Я выбрал этот пример, потому что большинство из нас уже знакомо с сложением и умножением, поэтому легко увидеть, насколько математика полезна для нас в данном случае.

Не отчаивайтесь — на протяжении всей книги мы будем вставлять некоторые элементы теории категорий, теории множеств и лямбда-исчисления и писать реальные примеры, которые достигают той же элегантной простоты и результатов, что и наш пример со стаей чаек. Вам не нужно быть математиком. Это будет казаться естественным и легким, как если бы вы использовали «обычный» фреймворк или API.

Возможно, вас удивит, что мы можем писать полноценные повседневные приложения по аналогии с функциональным аналогом, приведенным выше. Программы, которые имеют здравые свойства. Программы, которые лаконичны, но при этом просты для понимания. Программы, которые не изобретают велосипед заново на каждом шагу. Беззаконие — это хорошо, если вы преступник, но в этой книге мы хотим признать и подчиняться законам математики.

Мы хотим использовать теорию, в которой все части так вежливо сочетаются друг с другом. Мы хотим представить нашу конкретную проблему в виде общих, комбинируемых частей, а затем использовать

[[2. Функции первого класса|2-я глава]]

[^1]: от англ. bug - жук, жучок
	

[^2]: **Кса́наду** ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") Xanadu; более точная транскрипция с английского — **За́наду**) — принятое в западноевропейской традиции [Нового времени](https://ru.wikipedia.org/wiki/%D0%9D%D0%BE%D0%B2%D0%BE%D0%B5_%D0%B2%D1%80%D0%B5%D0%BC%D1%8F "Новое время") название **[Шанду](https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%BD%D0%B4%D1%83 "Шанду")**, летней резиденции монгольского императора [Хубилая](https://ru.wikipedia.org/wiki/%D0%A5%D1%83%D0%B1%D0%B8%D0%BB%D0%B0%D0%B9 "Хубилай"). В настоящее время используется в ряде имён собственных, в том числе в ассоциации этого слова с роскошной и праздной жизнью.
